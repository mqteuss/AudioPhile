<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Spobrefy</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1DB954"/>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="apple-touch-icon" href="icon-192x192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512x512.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            color: #e5e5e5;
        }

        #app-background {
            position: fixed;
            top: -10px; left: -10px;
            width: calc(100% + 20px);
            height: calc(100% + 20px);
            background-size: cover;
            background-position: center;
            filter: blur(20px) brightness(0.4);
            transition: background-image 0.7s ease-in-out;
            z-index: -1;
        }

        #progress-bar {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            cursor: pointer;
            outline: none;
            border-radius: 15px;
            height: 18px; 
            background: transparent;
        }

        #progress-bar::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(to right, #1DB954 var(--progress-percent, 0%), rgba(255, 255, 255, 0.2) var(--progress-percent, 0%));
            border-radius: 15px;
            transition: height 0.2s ease-in-out;
        }
        #progress-bar::-moz-range-track {
            height: 4px;
            background: linear-gradient(to right, #1DB954 var(--progress-percent, 0%), rgba(255, 255, 255, 0.2) var(--progress-percent, 0%));
            border-radius: 15px;
            transition: height 0.2s ease-in-out;
        }

        #progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #e5e5e5;
            border-radius: 50%;
            border: none;
            margin-top: -6px; 
            transition: transform 0.2s ease-in-out, background 0.2s ease-in-out;
            transform: scale(0); 
        }
         #progress-bar::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #e5e5e5;
            border-radius: 50%;
            border: none;
            transition: transform 0.2s ease-in-out, background 0.2s ease-in-out;
            transform: scale(0);
        }

        .progress-container:hover #progress-bar::-webkit-slider-runnable-track,
        .progress-container:hover #progress-bar::-moz-range-track {
            height: 6px;
        }
        .progress-container:hover #progress-bar::-webkit-slider-thumb,
        .progress-container:hover #progress-bar::-moz-range-thumb {
            transform: scale(1);
        }
         .progress-container:hover #progress-bar::-webkit-slider-thumb {
            margin-top: -5px; 
        }

        #progress-bar:active::-webkit-slider-thumb,
        #progress-bar:focus::-webkit-slider-thumb,
        #progress-bar:active::-moz-range-thumb,
        #progress-bar:focus::-moz-range-thumb {
             background: #1DB954;
        }

        .view {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }
        .view:not(.active) {
            opacity: 0;
            transform: scale(0.98);
            pointer-events: none;
        }

        .repeat-mode-one::after {
            content: '1';
            position: absolute;
            top: -2px; right: -4px;
            font-size: 9px;
            font-weight: bold;
            background-color: #1DB954;
            color: #121212;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            line-height: 12px;
            text-align: center;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }

        .modal-overlay { transition: opacity 0.3s ease-in-out; }
        .modal-content { transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28); }

        /* Animações para o Toast */
        @keyframes toast-in {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes toast-out {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }

        .toast-in { animation: toast-in 0.4s ease-in-out forwards; }
        .toast-out { animation: toast-out 0.4s ease-in-out forwards; }

        @keyframes nav-icon-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(0.85); }
            100% { transform: scale(1); }
        }
        .nav-icon-bounce { animation: nav-icon-bounce 0.3s ease-in-out; }

        #playlist-song-list {
            counter-reset: song-counter;
        }
        #playlist-song-list .song-item .song-number-container {
            position: absolute;
            top: 0; left: 0;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: #a1a1aa;
            transition: opacity 0.2s ease-in-out;
        }
        #playlist-song-list .song-item .song-number-container::before {
            counter-increment: song-counter;
            content: counter(song-counter);
        }
        #playlist-song-list .song-item .song-cover {
            transition: opacity 0.2s ease-in-out;
            opacity: 1;
        }
        #playlist-song-list .song-item .clickable-area:hover .song-cover {
            opacity: 0.2;
        }
        #playlist-song-list .song-item .song-number-container {
            opacity: 0;
        }
        #playlist-song-list .song-item .clickable-area:hover .song-number-container {
            opacity: 1;
        }

        /* Destaque genérico para música tocando */
        .song-item.playing .song-title {
            color: #1DB954;
        }
    </style>
</head>
<body class="bg-black antialiased overflow-hidden" style="padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom);">

    <div id="app-background"></div>

    <input type="file" id="music-folder-input" webkitdirectory directory multiple class="hidden">

    <main id="app-content" class="h-screen w-screen relative">

        <div id="player-view" class="view active flex flex-col justify-start items-center p-6 pt-10 md:pt-12">
            <div class="w-full max-w-sm">
                <img id="album-cover" src="https://placehold.co/500x500/101010/1DB954?text=Spobrefy" alt="Capa do Álbum" class="w-full aspect-square rounded-lg shadow-2xl object-cover">
                
                <div class="flex justify-between items-center my-8 gap-4">
                    <div class="flex-grow min-w-0">
                        <h2 id="track-title" class="text-2xl font-bold truncate text-left">Bem-vindo!</h2>
                        <h3 id="track-artist" class="text-md text-zinc-400 truncate text-left">Sincronize ou adicione suas músicas</h3>
                    </div>
                    <button id="add-to-playlist-from-player-btn" class="control-btn p-2 w-12 h-12 flex-shrink-0 flex items-center justify-center text-zinc-400 hover:text-white transition-colors" title="Adicionar à playlist">
                        <i class="fas fa-plus text-xl"></i>
                    </button>
                </div>
                <div>
                     <div class="progress-container mb-2">
                         <input type="range" id="progress-bar" class="w-full appearance-none cursor-pointer" value="0" step="1">
                         <div class="flex justify-between text-xs text-zinc-400 mt-1.5">
                             <span id="current-time">0:00</span>
                             <span id="duration">0:00</span>
                         </div>
                     </div>
                     <div class="flex justify-between items-center text-zinc-200 px-2 my-6">
                         <button id="shuffle-btn" class="control-btn p-2 w-12 h-12 flex items-center justify-center transition-colors relative" title="Aleatório"><i class="fas fa-shuffle text-xl"></i></button>
                         <button id="prev-btn" class="control-btn p-2 transition-colors" title="Anterior"><i class="fas fa-backward-step text-4xl"></i></button>
                         <button id="play-pause-btn" class="control-btn bg-white text-black rounded-full w-20 h-20 flex items-center justify-center hover:scale-105 transition-transform shadow-lg" title="Play/Pause"><i class="fas fa-play text-3xl ml-1"></i></button>
                         <button id="next-btn" class="control-btn p-2 transition-colors" title="Próxima"><i class="fas fa-forward-step text-4xl"></i></button>
                         <button id="repeat-btn" class="control-btn p-2 w-12 h-12 flex items-center justify-center transition-colors relative" title="Repetir"><i class="fas fa-repeat text-xl"></i></button>
                     </div>
                </div>
            </div>
        </div>

        <div id="search-view" class="view pb-20 flex flex-col">
            <h1 class="text-3xl font-bold px-6 md:px-8 pt-6 md:pt-8 mb-4 flex-shrink-0">Catálogo</h1>
        
            <div class="sticky top-0 z-10 px-6 md:px-8 py-3 flex-shrink-0" style="padding-top: calc(0.75rem + env(safe-area-inset-top));">
                <div class="flex items-center gap-3">
                    <div class="relative flex-grow">
                        <input type="text" id="search-input" placeholder="O que você quer ouvir?" class="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-2 pl-10 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-green-500">
                        <i class="fas fa-search absolute left-4 top-1/2 -translate-y-1/2 text-zinc-500"></i>
                    </div>
                    <button id="add-music-btn" title="Adicionar Pasta de Músicas" class="flex-shrink-0 text-zinc-400 hover:text-white bg-zinc-800 hover:bg-zinc-700 transition-colors w-10 h-10 flex items-center justify-center rounded-lg">
                        <i class="fas fa-folder-plus text-xl"></i>
                    </button>
                    <button id="sync-btn" title="Sincronizar Catálogo" class="flex-shrink-0 text-zinc-400 hover:text-white bg-zinc-800 hover:bg-zinc-700 transition-colors w-10 h-10 flex items-center justify-center rounded-lg disabled:opacity-50 disabled:cursor-wait">
                        <i class="fas fa-sync text-lg"></i>
                    </button>
                </div>
            </div>
        
            <div class="px-6 md:px-8 flex-grow relative">
                <div id="library-empty-state" class="text-center text-zinc-500 mt-16 absolute inset-0 flex flex-col items-center justify-center">
                    <i id="library-empty-icon" class="fas fa-music text-5xl mb-4"></i>
                    <h3 id="library-empty-title" class="text-xl font-semibold text-white mb-2">Sua biblioteca está vazia</h3>
                    <p id="library-empty-text">Use o botão <i class="fas fa-folder-plus"></i> para começar.</p>
                </div>
                <div id="song-list" class="mt-4 h-full"></div>
            </div>
        </div>


        <div id="playlists-view" class="view p-6 md:p-8 pb-20">
             <h1 class="text-3xl font-bold mb-6">Suas Playlists</h1>
               <div id="playlist-grid" class="grid grid-cols-1 gap-4"></div>
        </div>

        <div id="playlist-details-view" class="view p-6 md:p-8 pb-20 flex flex-col">
            <div class="flex items-center mb-4 flex-shrink-0">
                <button id="back-to-playlists-btn" class="p-2 mr-2 flex-shrink-0"><i class="fas fa-arrow-left text-xl"></i></button>
            </div>
            <div class="text-center px-4 flex-shrink-0">
                <div id="playlist-details-cover" class="w-48 h-48 mx-auto rounded-lg bg-zinc-800 flex items-center justify-center shadow-lg mb-4 overflow-hidden">
                    <img id="playlist-details-cover-img" src="" alt="Capa da Playlist" class="w-full h-full object-cover hidden" loading="lazy">
                    <i id="playlist-details-cover-icon" class="fas fa-music text-6xl text-zinc-600"></i>
                </div>
                <div class="flex items-center justify-center gap-2">
                    <h1 id="playlist-details-title" class="text-3xl font-bold truncate">Nome da Playlist</h1>
                    <button id="edit-playlist-title-btn" class="text-zinc-500 hover:text-white" title="Renomear playlist"><i class="fas fa-pencil"></i></button>
                </div>
                <p id="playlist-details-meta" class="text-zinc-400 text-sm mt-1"></p>

                <div class="flex justify-center items-center gap-4 my-6">
                    <button id="playlist-play-btn" class="bg-green-500 text-black font-bold py-3 px-6 rounded-full hover:scale-105 transition-transform text-lg">Play</button>
                    <button id="playlist-shuffle-btn" class="border border-zinc-600 text-white font-bold py-3 px-6 rounded-full hover:bg-zinc-700 transition-colors text-lg">Shuffle</button>
                    <button id="playlist-download-all-btn" class="border border-zinc-600 text-zinc-300 w-12 h-12 rounded-full hover:bg-zinc-700 transition-colors flex items-center justify-center" title="Baixar todas as músicas da playlist">
                        <i class="fas fa-download"></i>
                    </button>
                </div>
             </div>
             <div class="flex-grow relative mt-4">
                <div id="playlist-empty-state" class="text-center text-zinc-500 mt-10 hidden absolute inset-0 flex flex-col items-center justify-center">
                    <i class="fas fa-compact-disc text-5xl mb-4"></i>
                    <h3 class="text-xl font-semibold text-white mb-2">Esta playlist está vazia</h3>
                    <p>Adicione músicas do seu catálogo para começar.</p>
                </div>
                <div id="playlist-song-list" class="h-full"></div>
            </div>
        </div>
    </main>

    <nav class="fixed bottom-0 left-0 right-0 h-[64px] bg-zinc-900/50 backdrop-blur-lg flex justify-around items-center border-t border-zinc-800">
        <button data-view="search-view" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-zinc-400 transition-colors">
            <i class="fas fa-search text-xl"></i>
            <span class="text-xs">Catálogo</span>
        </button>
        <button data-view="player-view" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-green-500 transition-colors">
            <i class="fas fa-circle-play text-xl"></i>
            <span class="text-xs">Player</span>
        </button>
        <button data-view="playlists-view" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-zinc-400 transition-colors">
            <i class="fas fa-bars-staggered text-xl"></i>
            <span class="text-xs">Playlists</span>
        </button>
        <button id="create-playlist-btn" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-zinc-400 transition-colors">
            <i class="fas fa-plus text-xl"></i>
            <span class="text-xs">Criar</span>
        </button>
    </nav>

    <div id="create-playlist-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-6 shadow-2xl transform scale-95">
             <h2 id="playlist-modal-title" class="text-xl font-bold text-center mb-4">Criar nova playlist</h2>
             <input id="playlist-name-input" type="text" placeholder="Dê um nome à sua playlist" class="w-full bg-zinc-700 border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:outline-none focus:ring-2 focus:ring-green-500 mb-6">
             <div class="flex justify-end gap-3">
                 <button id="cancel-playlist-btn" class="px-5 py-2 rounded-full font-semibold transition-colors hover:bg-zinc-700">Cancelar</button>
                 <button id="confirm-playlist-btn" class="bg-green-500 text-black px-5 py-2 rounded-full font-semibold transition-colors hover:bg-green-400">Criar</button>
             </div>
        </div>
    </div>

    <div id="add-to-playlist-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-end sm:items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-2 shadow-2xl transform translate-y-full sm:translate-y-0 sm:scale-95">
             <h2 class="text-xl font-bold text-center p-4">Adicionar à playlist</h2>
             <div id="playlist-selection-list" class="max-h-60 overflow-y-auto"></div>
             <button id="add-to-playlist-cancel-btn" class="w-full p-4 mt-2 font-semibold hover:bg-zinc-700 rounded-lg">Cancelar</button>
        </div>
    </div>

    <div id="song-options-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-end sm:items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-2 shadow-2xl transform translate-y-full sm:translate-y-0 sm:scale-95">
            <div class="p-4 border-b border-zinc-700">
                <p id="options-modal-title" class="font-bold text-center truncate">Nome da Música</p>
                <p id="options-modal-artist" class="text-sm text-zinc-400 text-center truncate">Artista</p>
            </div>
            <ul class="text-center">
                <li id="options-add-to-playlist-li"><button id="options-add-to-playlist-btn" class="w-full text-left p-4 hover:bg-zinc-700 rounded-lg">Adicionar à playlist</button></li>
                <li id="options-remove-from-playlist-li"><button id="options-remove-from-playlist-btn" class="w-full text-left p-4 hover:bg-zinc-700 rounded-lg text-red-500">Remover da playlist</button></li>
                <li><button id="options-download-btn" class="w-full text-left p-4 hover:bg-zinc-700 rounded-lg">Baixar</button></li>
            </ul>
             <button id="options-cancel-btn" class="w-full p-4 mt-2 font-semibold hover:bg-zinc-700 rounded-lg">Cancelar</button>
        </div>
    </div>

    <div id="confirmation-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-6 shadow-2xl transform scale-95">
             <p id="confirmation-modal-text" class="text-center mb-6"></p>
             <div class="flex justify-end gap-3">
                 <button id="confirmation-cancel-btn" class="px-5 py-2 rounded-full font-semibold transition-colors hover:bg-zinc-700">Cancelar</button>
                 <button id="confirmation-ok-btn" class="bg-red-500 text-white px-5 py-2 rounded-full font-semibold transition-colors hover:bg-red-400">OK</button>
             </div>
        </div>
    </div>

    <div id="notification-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-6 shadow-2xl transform scale-95">
             <p id="notification-modal-text" class="text-center mb-6"></p>
             <div class="flex justify-end">
                 <button id="notification-ok-btn" class="bg-green-500 text-black px-5 py-2 rounded-full font-semibold transition-colors hover:bg-green-400">OK</button>
             </div>
        </div>
    </div>

    <template id="song-item-template">
        <li class="song-item group flex items-center gap-3 p-3 rounded-lg hover:bg-zinc-800/80 transition-colors">
            <div class="clickable-area flex-grow min-w-0 flex items-center gap-3 cursor-pointer">
                <div class="relative w-12 h-12 flex-shrink-0">
                    <div class="song-number-container"></div>
                    <img class="song-cover w-full h-full rounded-md object-cover" src="https://placehold.co/100x100/27272a/3f3f46?text=?" alt="Capa" loading="lazy">
                </div>
                <div class="flex-grow min-w-0">
                    <p class="song-title font-semibold truncate"></p>
                    <p class="song-artist text-sm text-zinc-400 truncate"></p>
                </div>
            </div>
            <i class="offline-indicator fas fa-check-circle text-green-500 hidden mr-2" title="Disponível offline"></i>
            <button class="options-btn text-zinc-400 hover:text-white p-2 rounded-full hover:bg-zinc-700" title="Mais opções">
                <i class="fas fa-ellipsis-v"></i>
            </button>
        </li>
    </template>

    <template id="playlist-item-template">
        <div class="playlist-item-grid-entry group flex items-center justify-between gap-4 p-3 rounded-lg bg-zinc-900/50 hover:bg-zinc-800/80 transition-colors">
            <div class="playlist-clickable-area flex-grow flex items-center gap-4 cursor-pointer">
                <img class="playlist-cover w-16 h-16 rounded-md object-cover" src="https://placehold.co/100x100/101010/1DB954?text=PLAY" alt="Capa da Playlist" loading="lazy">
                <div>
                    <p class="playlist-name font-semibold"></p>
                    <p class="playlist-song-count text-sm text-zinc-400"></p>
                </div>
            </div>
            <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                <button class="edit-playlist-btn text-zinc-500 hover:text-white p-2" title="Renomear playlist"><i class="fas fa-pencil"></i></button>
                <button class="delete-playlist-btn text-zinc-500 hover:text-red-500 p-2" title="Excluir playlist"><i class="fas fa-trash"></i></button>
            </div>
        </div>
    </template>

    <div id="toast-container" class="fixed bottom-20 sm:bottom-4 right-4 z-50 flex flex-col items-end gap-3"></div>

<script>
    // Sistema de Virtualização para Listas
    const VirtualScroller = {
        instances: new Map(),

        create(containerId, options = {}) {
            const config = {
                itemHeight: options.itemHeight || 64,
                buffer: options.buffer || 5,
                renderItem: options.renderItem || (() => {}),
                data: options.data || [],
                container: document.getElementById(containerId),
            };

            if (!config.container) {
                console.error(`Container ${containerId} não encontrado`);
                return null;
            }

            const instance = {
                config,
                viewport: null,
                content: null,
                visibleItems: new Map(),
                scrollTop: 0,
                startIndex: 0,
                endIndex: 0,

                init() {
                    this.setupDOM();
                    this.update();
                    this.bindEvents();
                },

                setupDOM() {
                    this.config.container.innerHTML = '';
                    this.config.container.style.position = 'relative';
                    this.config.container.style.overflow = 'auto';
                    this.config.container.style.height = '100%';

                    this.viewport = document.createElement('div');
                    this.viewport.style.position = 'relative';
                    this.viewport.style.width = '100%';
                    this.viewport.style.height = `${this.config.data.length * this.config.itemHeight}px`;

                    this.content = document.createElement('div');
                    this.content.style.position = 'absolute';
                    this.content.style.top = '0';
                    this.content.style.left = '0';
                    this.content.style.width = '100%';

                    this.viewport.appendChild(this.content);
                    this.config.container.appendChild(this.viewport);
                },

                bindEvents() {
                    this.config.container.addEventListener('scroll', () => {
                        this.scrollTop = this.config.container.scrollTop;
                        requestAnimationFrame(() => this.update());
                    });
                },

                update() {
                    const { itemHeight, buffer, data } = this.config;
                    const containerHeight = this.config.container.clientHeight;

                    this.startIndex = Math.max(0, Math.floor(this.scrollTop / itemHeight) - buffer);
                    this.endIndex = Math.min(
                        data.length - 1,
                        Math.ceil((this.scrollTop + containerHeight) / itemHeight) + buffer
                    );

                    this.render();
                },

                render() {
                    const { data, itemHeight } = this.config;
                    const newVisibleItems = new Map();

                    // Remove itens que saíram da viewport
                    for (const [index, element] of this.visibleItems) {
                        if (index < this.startIndex || index > this.endIndex) {
                            element.remove();
                            App.cleanupItemURLs(element);
                        } else {
                            newVisibleItems.set(index, element);
                        }
                    }

                    // Adiciona novos itens visíveis
                    for (let i = this.startIndex; i <= this.endIndex; i++) {
                        if (!newVisibleItems.has(i)) {
                            const item = data[i];
                            const element = this.config.renderItem(item, i);
                            element.style.position = 'absolute';
                            element.style.top = `${i * itemHeight}px`;
                            element.style.width = '100%';
                            element.style.height = `${itemHeight}px`;
                            
                            this.content.appendChild(element);
                            newVisibleItems.set(i, element);
                        }
                    }

                    this.visibleItems = newVisibleItems;
                },

                setData(newData) {
                    this.config.data = newData;
                    this.viewport.style.height = `${newData.length * this.config.itemHeight}px`;
                    this.visibleItems.forEach(el => el.remove());
                    this.visibleItems.clear();
                    this.update();
                },

                scrollToIndex(index) {
                    const { itemHeight } = this.config;
                    this.config.container.scrollTop = index * itemHeight;
                },

                destroy() {
                    this.visibleItems.forEach(el => {
                        App.cleanupItemURLs(el);
                        el.remove();
                    });
                    this.visibleItems.clear();
                    this.config.container.innerHTML = '';
                }
            };

            instance.init();
            this.instances.set(containerId, instance);
            return instance;
        },

        get(containerId) {
            return this.instances.get(containerId);
        },

        destroy(containerId) {
            const instance = this.instances.get(containerId);
            if (instance) {
                instance.destroy();
                this.instances.delete(containerId);
            }
        }
    };
    
    document.addEventListener('DOMContentLoaded', () => {
        const App = {
            dom: {
                appContent: document.getElementById('app-content'),
                background: document.getElementById('app-background'),
                albumCover: document.getElementById('album-cover'),
                trackTitle: document.getElementById('track-title'),
                trackArtist: document.getElementById('track-artist'),
                progressBar: document.getElementById('progress-bar'),
                currentTimeEl: document.getElementById('current-time'),
                durationEl: document.getElementById('duration'),
                playPauseBtn: document.getElementById('play-pause-btn'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                shuffleBtn: document.getElementById('shuffle-btn'),
                repeatBtn: document.getElementById('repeat-btn'),
                navButtons: document.querySelectorAll('.nav-btn'),
                views: document.querySelectorAll('.view'),
                addMusicBtn: document.getElementById('add-music-btn'),
                syncBtn: document.getElementById('sync-btn'),
                musicFolderInput: document.getElementById('music-folder-input'),
                songList: document.getElementById('song-list'),
                libraryEmptyState: document.getElementById('library-empty-state'),
                libraryEmptyIcon: document.getElementById('library-empty-icon'),
                libraryEmptyTitle: document.getElementById('library-empty-title'),
                libraryEmptyText: document.getElementById('library-empty-text'),
                songItemTemplate: document.getElementById('song-item-template'),
                searchInput: document.getElementById('search-input'),
                playlistGrid: document.getElementById('playlist-grid'),
                playlistItemTemplate: document.getElementById('playlist-item-template'),
                createPlaylistBtn: document.getElementById('create-playlist-btn'),
                createPlaylistModal: document.getElementById('create-playlist-modal'),
                playlistModalTitle: document.getElementById('playlist-modal-title'),
                cancelPlaylistBtn: document.getElementById('cancel-playlist-btn'),
                confirmPlaylistBtn: document.getElementById('confirm-playlist-btn'),
                playlistNameInput: document.getElementById('playlist-name-input'),
                addToPlaylistModal: document.getElementById('add-to-playlist-modal'),
                playlistSelectionList: document.getElementById('playlist-selection-list'),
                addToPlaylistCancelBtn: document.getElementById('add-to-playlist-cancel-btn'),
                playlistDetailsView: document.getElementById('playlist-details-view'),
                backToPlaylistsBtn: document.getElementById('back-to-playlists-btn'),
                playlistDetailsTitle: document.getElementById('playlist-details-title'),
                editPlaylistTitleBtn: document.getElementById('edit-playlist-title-btn'),
                playlistDetailsMeta: document.getElementById('playlist-details-meta'),
                playlistDetailsCover: document.getElementById('playlist-details-cover'),
                playlistDetailsCoverImg: document.getElementById('playlist-details-cover-img'),
                playlistDetailsCoverIcon: document.getElementById('playlist-details-cover-icon'),
                playlistSongList: document.getElementById('playlist-song-list'),
                playlistPlayBtn: document.getElementById('playlist-play-btn'),
                playlistShuffleBtn: document.getElementById('playlist-shuffle-btn'),
                playlistDownloadAllBtn: document.getElementById('playlist-download-all-btn'),
                playlistEmptyState: document.getElementById('playlist-empty-state'),
                songOptionsModal: document.getElementById('song-options-modal'),
                optionsModalTitle: document.getElementById('options-modal-title'),
                optionsModalArtist: document.getElementById('options-modal-artist'),
                optionsAddToPlaylistBtn: document.getElementById('options-add-to-playlist-btn'),
                optionsAddToPlaylistLi: document.getElementById('options-add-to-playlist-li'),
                optionsRemoveFromPlaylistBtn: document.getElementById('options-remove-from-playlist-btn'),
                optionsRemoveFromPlaylistLi: document.getElementById('options-remove-from-playlist-li'),
                optionsDownloadBtn: document.getElementById('options-download-btn'),
                optionsCancelBtn: document.getElementById('options-cancel-btn'),
                confirmationModal: document.getElementById('confirmation-modal'),
                confirmationModalText: document.getElementById('confirmation-modal-text'),
                confirmationCancelBtn: document.getElementById('confirmation-cancel-btn'),
                confirmationOkBtn: document.getElementById('confirmation-ok-btn'),
                notificationModal: document.getElementById('notification-modal'),
                notificationModalText: document.getElementById('notification-modal-text'),
                notificationOkBtn: document.getElementById('notification-ok-btn'),
                toastContainer: document.getElementById('toast-container'),
                addToPlaylistFromPlayerBtn: document.getElementById('add-to-playlist-from-player-btn'),
            },

            state: {
                songs: [],
                playlists: [],
                currentSongIndex: -1,
                isPlaying: false,
                isShuffle: false,
                repeatMode: 'none',
                currentPlaylistId: null,
                playQueue: [],
                currentQueueIndex: -1,
                restoredState: null,
                touchStartX: 0,
                touchEndX: 0,
                viewOrder: ['search-view', 'player-view', 'playlists-view'],
                currentObjectUrl: null,
                currentPlayerCoverUrl: null,
                debounceTimer: null,
                songIdForOptions: null,
                isPlaylistContextForOptions: false,
                confirmationCallback: null,
                playlistIdToEdit: null,
                activeToastTimeout: null, 
            },

            audio: new Audio(),
            imageObserver: null,
            CACHE_NAME: 'spobrefy-audio-cache-v1',

            createThumbnail(imageBlob, width = 100, height = 100) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const objectURL = URL.createObjectURL(imageBlob);
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        const sourceWidth = img.naturalWidth;
                        const sourceHeight = img.naturalHeight;
                        const sourceAspectRatio = sourceWidth / sourceHeight;
                        const targetAspectRatio = width / height;
                        let drawWidth = width;
                        let drawHeight = height;
                        let x = 0;
                        let y = 0;
                        if (sourceAspectRatio > targetAspectRatio) {
                            drawHeight = height;
                            drawWidth = drawHeight * sourceAspectRatio;
                            x = (width - drawWidth) / 2;
                            y = 0;
                        } else {
                            drawWidth = width;
                            drawHeight = drawWidth / sourceAspectRatio;
                            x = 0;
                            y = (height - drawHeight) / 2;
                        }
                        ctx.drawImage(img, x, y, drawWidth, drawHeight);
                        canvas.toBlob(
                            (blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Falha ao criar o blob da miniatura.'));
                                }
                                URL.revokeObjectURL(objectURL);
                            },
                            'image/jpeg',
                            0.8
                        );
                    };
                    img.onerror = () => {
                        reject(new Error('Falha ao carregar a imagem para criar miniatura.'));
                        URL.revokeObjectURL(objectURL);
                    };
                    img.src = objectURL;
                });
            },

            async init() {
                this.virtualScrollers = {
                    songList: null,
                    playlistSongList: null
                };
                this.registerServiceWorker();
                await this.initDB();
                this.setupImageObserver();
                this.bindEvents();
                this.setupMediaSession();
                await this.loadSongsFromDB();
                await this.loadPlaylistsFromDB();
                await this.syncWithServerFolder();
                await this.loadPlaybackState();
                this.updateRepeatButtonUI();
                this.updateShuffleButtonUI();
                this.switchView('player-view');
            },

            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js')
                        .then(reg => console.log('Service Worker: Registrado'))
                        .catch(err => console.log(`Service Worker: Erro: ${err}`));
                }
            },
            
            debounce(func, delay) {
                return (...args) => {
                    clearTimeout(this.state.debounceTimer);
                    this.state.debounceTimer = setTimeout(() => func.apply(this, args), delay);
                };
            },

            animateIcon(element) {
                const icon = element.querySelector('i');
                if (icon) {
                    icon.classList.add('nav-icon-bounce');
                    icon.addEventListener('animationend', () => icon.classList.remove('nav-icon-bounce'), { once: true });
                }
            },

            bindEvents() {
                this.dom.navButtons.forEach(btn => btn.dataset.view && btn.addEventListener('click', e => { this.switchView(e.currentTarget.dataset.view); this.animateIcon(e.currentTarget); }));
                this.dom.playPauseBtn.addEventListener('click', e => { this.togglePlayPause(); this.animateIcon(e.currentTarget); });
                this.dom.nextBtn.addEventListener('click', e => { this.changeTrack('next'); this.animateIcon(e.currentTarget); });
                this.dom.prevBtn.addEventListener('click', e => { this.changeTrack('prev'); this.animateIcon(e.currentTarget); });
                this.dom.repeatBtn.addEventListener('click', e => { this.toggleRepeatMode(); this.animateIcon(e.currentTarget); });
                this.dom.shuffleBtn.addEventListener('click', e => { this.toggleShuffle(); this.animateIcon(e.currentTarget); });
                this.dom.progressBar.addEventListener('input', e => this.seek(e.target.value));
                this.audio.addEventListener('timeupdate', () => this.updateProgress());
                this.audio.addEventListener('ended', () => this.handleSongEnd());
                this.audio.addEventListener('loadedmetadata', () => this.handleMetadataLoaded());
                this.audio.addEventListener('pause', () => this.savePlaybackState());
                this.audio.addEventListener('volumechange', () => this.savePlaybackState());
                window.addEventListener('beforeunload', () => this.savePlaybackState());
                this.dom.addMusicBtn.addEventListener('click', () => this.dom.musicFolderInput.click());
                this.dom.syncBtn.addEventListener('click', () => this.syncWithServerFolder());
                this.dom.musicFolderInput.addEventListener('change', e => this.addMusicFiles(e.target.files));
                this.dom.searchInput.addEventListener('input', this.debounce(e => this.filterSongList(e.target.value), 250));
                this.dom.createPlaylistBtn.addEventListener('click', () => this.openCreatePlaylistModal());
                this.dom.cancelPlaylistBtn.addEventListener('click', () => this.showPlaylistModal(false));
                this.dom.confirmPlaylistBtn.addEventListener('click', () => this.handlePlaylistFormSubmit());
                this.dom.createPlaylistModal.addEventListener('click', e => { if (e.target === this.dom.createPlaylistModal) this.showPlaylistModal(false); });
                this.dom.addToPlaylistModal.addEventListener('click', e => { if (e.target === this.dom.addToPlaylistModal) this.showAddToPlaylistModal(false); });
                this.dom.addToPlaylistCancelBtn.addEventListener('click', () => this.showAddToPlaylistModal(false));
                this.dom.playlistSelectionList.addEventListener('click', e => {
                    const listItem = e.target.closest('[data-playlist-id]');
                    if(listItem) this.addSongToPlaylist(parseInt(listItem.dataset.playlistId));
                });
                this.dom.optionsCancelBtn.addEventListener('click', () => this.showSongOptionsModal(false));
                this.dom.songOptionsModal.addEventListener('click', e => { if (e.target === this.dom.songOptionsModal) this.showSongOptionsModal(false); });
                this.dom.optionsAddToPlaylistBtn.addEventListener('click', () => { this.showAddToPlaylistModal(true); this.showSongOptionsModal(false); });
                this.dom.optionsRemoveFromPlaylistBtn.addEventListener('click', () => { this.removeSongFromPlaylist(); this.showSongOptionsModal(false); });
                this.dom.optionsDownloadBtn.addEventListener('click', () => { this.toggleSongOfflineStatus(); this.showSongOptionsModal(false); });
                this.dom.confirmationCancelBtn.addEventListener('click', () => this.showConfirmationModal(null, null, false));
                this.dom.confirmationOkBtn.addEventListener('click', () => {
                    if (typeof this.state.confirmationCallback === 'function') {
                        this.state.confirmationCallback();
                    }
                    this.showConfirmationModal(null, null, false);
                });
                this.dom.notificationOkBtn.addEventListener('click', () => this.showNotificationModal(null, false));
                this.dom.playlistGrid.addEventListener('click', e => {
                    const entry = e.target.closest('.playlist-item-grid-entry');
                    if (!entry) return;
                    const playlistId = parseInt(entry.dataset.id);
                    if (e.target.closest('.delete-playlist-btn')) this.deletePlaylist(playlistId);
                    else if (e.target.closest('.edit-playlist-btn')) this.openRenamePlaylistModal(playlistId);
                    else if (e.target.closest('.playlist-clickable-area')) this.showPlaylistDetails(playlistId);
                });
                this.dom.backToPlaylistsBtn.addEventListener('click', () => this.switchView('playlists-view'));
                this.dom.playlistPlayBtn.addEventListener('click', () => this.playPlaylist(false));
                this.dom.playlistShuffleBtn.addEventListener('click', () => this.playPlaylist(true));
                this.dom.playlistDownloadAllBtn.addEventListener('click', () => this.downloadPlaylist());
                this.dom.editPlaylistTitleBtn.addEventListener('click', () => this.openRenamePlaylistModal(this.state.currentPlaylistId));
                
                // --- CÓDIGO CORRIGIDO ---
                this.dom.songList.addEventListener('click', e => {
                    const scroller = VirtualScroller.get('song-list');
                    const songs = scroller ? scroller.config.data : this.state.songs;
                    this.handleSongListClick(e, songs, false);
                });

                this.dom.playlistSongList.addEventListener('click', e => {
                    const scroller = VirtualScroller.get('playlist-song-list');
                    if (scroller) {
                        this.handleSongListClick(e, scroller.config.data, true);
                    }
                });
                // --- FIM DA CORREÇÃO ---

                this.dom.appContent.addEventListener('touchstart', e => this.handleTouchStart(e), false);
                this.dom.appContent.addEventListener('touchmove', e => this.handleTouchMove(e), false);
                this.dom.appContent.addEventListener('touchend', () => this.handleTouchEnd(), false);
                this.dom.addToPlaylistFromPlayerBtn.addEventListener('click', () => this.handleAddToPlaylistFromPlayer());
            },

            handleAddToPlaylistFromPlayer() {
                if (this.state.currentSongIndex === -1) {
                    this.showToast('Nenhuma música está tocando.', 'info');
                    return;
                }
                const currentSong = this.state.songs[this.state.currentSongIndex];
                if (currentSong) {
                    this.state.songIdForOptions = currentSong.id;
                    this.showAddToPlaylistModal(true);
                }
            },

            setupImageObserver() {
                this.imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            const src = img.getAttribute('data-src');
                            if (src) {
                                img.src = src;
                                img.removeAttribute('data-src');
                            }
                            observer.unobserve(img);
                        }
                    });
                }, { rootMargin: "100px" });
            },

            setupMediaSession() {
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.setActionHandler('play', () => this.play());
                    navigator.mediaSession.setActionHandler('pause', () => this.pause());
                    navigator.mediaSession.setActionHandler('nexttrack', () => this.changeTrack('next'));
                    navigator.mediaSession.setActionHandler('previoustrack', () => this.changeTrack('prev'));
                }
            },

            handleTouchStart(event) {
                const target = event.target.closest('button, input[type="range"], .progress-container, .modal-content');
                if (target) { this.state.touchStartX = 0; return; }
                this.state.touchStartX = event.changedTouches[0].screenX;
            },
            handleTouchMove(event) {
                this.state.touchEndX = event.changedTouches[0].screenX;
            },
            handleTouchEnd() {
                if (this.state.touchStartX === 0 || this.state.touchEndX === 0) return;
                const threshold = 60;
                const swipeDistance = this.state.touchEndX - this.state.touchStartX;
                const isSwipe = Math.abs(swipeDistance) > threshold;
                if (isSwipe) {
                    const activeView = document.querySelector('.view.active');
                    if (!activeView) return;
                    const currentIndex = this.state.viewOrder.indexOf(activeView.id);
                    if (currentIndex === -1) return;
                    let nextIndex;
                    if (swipeDistance < 0) {
                        nextIndex = Math.min(currentIndex + 1, this.state.viewOrder.length - 1);
                    } else {
                        nextIndex = Math.max(currentIndex - 1, 0);
                    }
                    if (nextIndex !== currentIndex) {
                        const nextViewId = this.state.viewOrder[nextIndex];
                        this.switchView(nextViewId);
                    }
                }
                this.state.touchStartX = 0;
                this.state.touchEndX = 0;
            },

            handleSongListClick(event, songSourceList, isPlaylistContext = false) {
                const songItem = event.target.closest('.song-item');
                if (!songItem) return;
                const songId = parseInt(songItem.dataset.songId);
                if (event.target.closest('.options-btn')) {
                    this.state.songIdForOptions = songId;
                    this.state.isPlaylistContextForOptions = isPlaylistContext;
                    this.showSongOptionsModal(true);
                } else if (event.target.closest('.clickable-area')) {
                    this.state.playQueue = [...songSourceList];
                    const queueIndex = this.state.playQueue.findIndex(s => s.id === songId);
                    const globalIndex = this.state.songs.findIndex(s => s.id === songId);
                    this.loadSong(globalIndex, true, queueIndex);
                    if (isPlaylistContext) {
                        this.switchView('player-view');
                    }
                }
            },
            
            async addSongToPlaylist(playlistId) {
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                const songId = this.state.songIdForOptions;
                if (playlist && songId && !playlist.songIds.includes(songId)) {
                    playlist.songIds.push(songId);
                    await this.savePlaylistToDB(playlist);
                    await this.loadPlaylistsFromDB();
                    this.showToast(`Adicionado a "${playlist.name}"`, 'success');
                }
                this.showAddToPlaylistModal(false);
            },

            async removeSongFromPlaylist() {
                const playlist = this.state.playlists.find(p => p.id === this.state.currentPlaylistId);
                const songId = this.state.songIdForOptions;
                if (playlist && songId) {
                    this.showConfirmationModal(`Remover "${this.state.songs.find(s => s.id === songId).title}" da playlist?`, async () => {
                        playlist.songIds = playlist.songIds.filter(id => id !== songId);
                        await this.savePlaylistToDB(playlist);
                        this.showPlaylistDetails(this.state.currentPlaylistId);
                        await this.loadPlaylistsFromDB();
                        this.showToast('Música removida da playlist.', 'success');
                    });
                }
            },
            
            _getAudioCache() {
                return caches.open(this.CACHE_NAME);
            },
            _getCacheKey(song) {
                return song.path || `local-file://${song.id}`;
            },
            async _addSongToCache(song, blob) {
                const cache = await this._getAudioCache();
                const key = this._getCacheKey(song);
                const response = new Response(blob);
                await cache.put(key, response);
            },
            async _addSongToCacheFromPath(song) {
                const cache = await this._getAudioCache();
                const key = this._getCacheKey(song);
                const response = await fetch(key);
                if (!response.ok) throw new Error(`Falha ao baixar para cache: ${response.statusText}`);
                await cache.put(key, response);
            },
            async _removeSongFromCache(song) {
                const cache = await this._getAudioCache();
                const key = this._getCacheKey(song);
                await cache.delete(key);
            },
            async _getSongFromCache(song) {
                const cache = await this._getAudioCache();
                const key = this._getCacheKey(song);
                return await cache.match(key);
            },
            
            async toggleSongOfflineStatus(songIdToToggle = null, showFeedback = true) {
                const songId = songIdToToggle || this.state.songIdForOptions;
                const song = this.state.songs.find(s => s.id === songId);
                if (!song) return;

                const download = async () => {
                    if (showFeedback) this.showToast(`Baixando "${song.title}"...`, 'info', 2000);
                    try {
                        if (song.path) {
                            await this._addSongToCacheFromPath(song);
                        } else {
                            console.warn("Tentativa de baixar música local sem um blob de origem.");
                            if (showFeedback) this.showToast('Falha ao baixar música local.', 'error');
                            return false;
                        }
                        song.isOffline = true;
                        await this.saveSongMetadataToDB(song);
                        if (showFeedback) this.showToast('Música disponível offline.', 'success');
                        return true;
                    } catch (error) {
                        console.error("Erro no download para o cache:", error);
                        if (showFeedback) this.showToast('Erro ao baixar música.', 'error');
                        song.isOffline = false;
                        await this.saveSongMetadataToDB(song);
                        return false;
                    } finally {
                        this.updateSongItemUI(songId);
                    }
                };

                if (song.isOffline) {
                    const removeAction = async () => {
                        await this._removeSongFromCache(song);
                        song.isOffline = false;
                        await this.saveSongMetadataToDB(song);
                        if (showFeedback) this.showToast('Música removida do offline.', 'info');
                        this.updateSongItemUI(songId);
                    };

                    if (!songIdToToggle) {
                        this.showConfirmationModal(`Deseja remover a versão offline de "${song.title}"?`, removeAction);
                    } else {
                        await removeAction();
                    }
                } else {
                    await download();
                }
            },

            updateSongItemUI(songId) {
                const song = this.state.songs.find(s => s.id === songId);
                if (!song) return;

                const songItems = document.querySelectorAll(`.song-item[data-song-id="${songId}"]`);
                songItems.forEach(item => {
                    const indicator = item.querySelector('.offline-indicator');
                    if (indicator) {
                        indicator.classList.toggle('hidden', !song.isOffline);
                    }
                });
                
                if (this.state.songIdForOptions === songId && !this.dom.songOptionsModal.classList.contains('pointer-events-none')) {
                    this.dom.optionsDownloadBtn.textContent = song.isOffline ? "Remover do offline" : "Baixar";
                    song.isOffline ? this.dom.optionsDownloadBtn.classList.add("text-red-500") : this.dom.optionsDownloadBtn.classList.remove("text-red-500");
                }
            },
            
            playPlaylist(shuffle = false) {
                const playlist = this.state.playlists.find(p => p.id === this.state.currentPlaylistId);
                if (!playlist || playlist.songIds.length === 0) return;
                let songsInPlaylist = playlist.songIds.map(id => this.state.songs.find(s => s.id === id)).filter(Boolean);
                this.state.isShuffle = shuffle;
                this.updateShuffleButtonUI();
                if (shuffle) {
                    for (let i = songsInPlaylist.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [songsInPlaylist[i], songsInPlaylist[j]] = [songsInPlaylist[j], songsInPlaylist[i]];
                    }
                }
                this.state.playQueue = songsInPlaylist;
                const firstSong = this.state.playQueue[0];
                const globalIndex = this.state.songs.findIndex(s => s.id === firstSong.id);
                this.loadSong(globalIndex, true, 0);
                this.switchView('player-view');
            },

            async syncWithServerFolder() {
                const syncIcon = this.dom.syncBtn.querySelector('i');
                syncIcon.classList.add('fa-spin');
                this.dom.syncBtn.disabled = true;

                try {
                    const response = await fetch('./musics-manifest.json');
                    if (!response.ok) {
                        throw new Error(`Falha ao buscar o manifesto de músicas: ${response.statusText}`);
                    }
                    const serverSongPaths = await response.json();

                    const existingPaths = new Set(this.state.songs.map(song => song.path));
                    const serverPathsSet = new Set(serverSongPaths);
                    const newPaths = serverSongPaths.filter(path => !existingPaths.has(path));
                    const pathsToRemove = this.state.songs.filter(song => song.path && !serverPathsSet.has(song.path));
                    let hasChanges = false;

                    if (newPaths.length > 0) {
                        hasChanges = true;
                        console.log(`🔎 Encontradas ${newPaths.length} novas músicas. Processando em paralelo...`);
                        const newSongsPromises = newPaths.map(async (path) => {
                            const metadata = await this.readRemoteAudioMetadata(path);
                            const songData = { ...metadata, path: path, isOffline: false };
                            await this.saveSongMetadataToDB(songData);
                        });
                        await Promise.all(newSongsPromises);
                        console.log(`✅ ${newPaths.length} novas músicas adicionadas.`);
                    }

                    if (pathsToRemove.length > 0) {
                        hasChanges = true;
                        console.log(`🗑️ Removendo ${pathsToRemove.length} músicas obsoletas em paralelo...`);
                        const deletePromises = pathsToRemove.map(song => this.deleteSongFromDB(song.id));
                        await Promise.all(deletePromises);
                        console.log(`✅ ${pathsToRemove.length} músicas obsoletas removidas.`);
                    }
                    
                    if (hasChanges) {
                        this.showToast('Catálogo sincronizado!', 'success');
                        console.log("🎶 Catálogo sincronizado. Recarregando dados...");
                        await this.loadSongsFromDB();
                        await this.loadPlaylistsFromDB();
                    } else {
                        this.showToast('Catálogo já está atualizado.', 'info');
                        console.log("✅ Catálogo já está atualizado.");
                    }

                } catch (error) {
                    console.error("Erro ao sincronizar músicas do servidor:", error);
                    this.showToast('Erro ao sincronizar biblioteca.', 'error');
                } finally {
                    syncIcon.classList.remove('fa-spin');
                    this.dom.syncBtn.disabled = false;
                }
            },

            switchView(e){this.dom.views.forEach(t=>t.classList.toggle("active",t.id===e)),this.dom.navButtons.forEach(t=>{t.dataset.view&&(t.classList.toggle("text-green-500",t.dataset.view===e),t.classList.toggle("text-zinc-400",t.dataset.view!==e))})},
            
            async loadSong(e, t = !1, s = -1) {
                if (!(e < 0 || e >= this.state.songs.length)) {
                    this.state.currentObjectUrl && (URL.revokeObjectURL(this.state.currentObjectUrl), this.state.currentObjectUrl = null), this.state.currentSongIndex = e;
                    const o = this.state.songs[e];
                    this.state.currentQueueIndex = s;
                    try {
                        if (o.isOffline) {
                            console.log(`▶️ Tocando offline (do cache): ${o.title}`);
                            const response = await this._getSongFromCache(o);
                            if (response) {
                                const dataBlob = await response.blob();
                                this.state.currentObjectUrl = URL.createObjectURL(dataBlob);
                                this.audio.src = this.state.currentObjectUrl;
                            } else {
                                console.warn("Dado offline não encontrado no cache, fazendo streaming."), this.audio.src = o.path
                            }
                        } else console.log(`▶️ Tocando online (streaming): ${o.title}`), this.audio.src = o.path
                    } catch (l) {
                        return void console.error("Erro ao carregar áudio: ", l)
                    }
                    this.updatePlayerUI(o);
                    this.updatePlayingSongUI(o.id);

                    if ("mediaSession" in navigator) {
                        if (navigator.mediaSession.metadata && navigator.mediaSession.metadata.artwork[0].src.startsWith("blob:")) {
                            URL.revokeObjectURL(navigator.mediaSession.metadata.artwork[0].src);
                        }
                        const artworkSrcBlob = o.artworkBlob || o.coverBlob;
                        const artworkUrl = artworkSrcBlob ? URL.createObjectURL(artworkSrcBlob) : "https://placehold.co/500x500/101010/1DB954?text=Spobrefy";
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: o.title || "Título Desconhecido",
                            artist: o.artist || "Artista Desconhecido",
                            album: o.album || "Spobrefy",
                            artwork: [{
                                src: artworkUrl,
                                sizes: "512x512",
                                type: artworkSrcBlob?.type || "image/jpeg"
                            }]
                        });
                    }
                    t && this.play()
                }
            },
            
            play(){this.state.songs.length!==0&&(this.state.isPlaying=!0,this.audio.play().then(()=>this.savePlaybackState()).catch(e=>console.error("Erro ao tocar:",e)),this.dom.playPauseBtn.innerHTML='<i class="fas fa-pause text-3xl"></i>',"mediaSession"in navigator&&(navigator.mediaSession.playbackState="playing"))},
            pause(){this.state.isPlaying=!1,this.audio.pause(),this.dom.playPauseBtn.innerHTML='<i class="fas fa-play text-3xl ml-1"></i>',"mediaSession"in navigator&&(navigator.mediaSession.playbackState="paused")},
            togglePlayPause(){this.state.currentSongIndex===-1&&this.state.songs.length>0?(this.state.playQueue=[...this.state.songs],this.loadSong(0,!0,0)):this.state.isPlaying?this.pause():this.play()},
            changeTrack(e){const t=this.state.playQueue.length>0?this.state.playQueue:this.state.songs;if(t.length!==0){let s;const o=this.state.currentQueueIndex;if(this.state.isShuffle)do{s=Math.floor(Math.random()*t.length)}while(t.length>1&&s===o);else s=e==="next"?(o+1)%t.length:(o-1+t.length)%t.length;const i=t[s],a=this.state.songs.findIndex(e=>e.id===i.id);this.loadSong(a,!0,s)}},
            
            handleSongEnd() {
                if (this.state.repeatMode === 'one') {
                    this.audio.currentTime = 0;
                    this.play();
                    return;
                }

                const isLastSongInQueue = this.state.playQueue.length > 0 && this.state.currentQueueIndex === this.state.playQueue.length - 1;
                
                const shouldStop = isLastSongInQueue && this.state.repeatMode === 'none' && !this.state.isShuffle;

                if (shouldStop) {
                    this.pause();
                    this.audio.currentTime = 0;
                } else {
                    this.changeTrack('next');
                }
            },

            handleMetadataLoaded(){const e=this.state.songs[this.state.currentSongIndex];e&&!e.duration&&(e.duration=this.audio.duration,this.saveSongMetadataToDB(e)),this.updateProgress(),this.state.restoredState&&e?.id===this.state.restoredState.songId&&(this.audio.currentTime=this.state.restoredState.currentTime,this.updateProgress(),this.state.restoredState=null)},
            savePlaybackState(){if(this.state.currentSongIndex===-1)return;const e=this.state.songs[this.state.currentSongIndex];if(!e)return;const t={songId:e.id,currentTime:this.audio.currentTime,volume:this.audio.volume};localStorage.setItem("spobrefyPlaybackState",JSON.stringify(t))},
            async loadPlaybackState(){const e=localStorage.getItem("spobrefyPlaybackState");if(e)try{const t=JSON.parse(e);this.audio.volume=t.volume||1;const s=this.state.songs.findIndex(e=>e.id===t.songId);s>-1&&(console.log(`Restaurando estado: Música ID ${t.songId} no tempo ${this.formatTime(t.currentTime)}`),this.state.restoredState=t,this.loadSong(s,!1),this.switchView("player-view"))}catch(o){console.error("Erro ao carregar o estado salvo:",o),localStorage.removeItem("spobrefyPlaybackState")}},
            seek(e){this.audio.duration&&(this.audio.currentTime=e/100*this.audio.duration,this.dom.progressBar.style.setProperty("--progress-percent",`${e}%`))},
            updatePlayerUI(e) {
                this.dom.trackTitle.textContent = e.title || "Título Desconhecido";
                this.dom.trackArtist.textContent = e.artist || "Artista Desconhecido";
                if (this.state.currentPlayerCoverUrl) {
                    URL.revokeObjectURL(this.state.currentPlayerCoverUrl);
                    this.state.currentPlayerCoverUrl = null;
                }
                const placeholder = "https://placehold.co/500x500/101010/1DB954?text=Spobrefy";
                const highResCover = e.artworkBlob || e.coverBlob;
                let coverUrl;
                if (highResCover) {
                    this.state.currentPlayerCoverUrl = URL.createObjectURL(highResCover);
                    coverUrl = this.state.currentPlayerCoverUrl;
                } else {
                    coverUrl = placeholder;
                }
                this.dom.albumCover.src = coverUrl;
                this.dom.background.style.backgroundImage = `url(${coverUrl})`;
            },
            updateProgress(){const{duration:e,currentTime:t}=this.audio;e&&(this.dom.progressBar.value=t/e*100,this.dom.progressBar.style.setProperty("--progress-percent",`${t/e*100}%`),this.dom.durationEl.textContent=this.formatTime(e)),this.dom.currentTimeEl.textContent=this.formatTime(t),"mediaSession"in navigator&&this.audio.duration&&navigator.mediaSession.setPositionState({duration:this.audio.duration,playbackRate:this.audio.playbackRate,position:this.audio.currentTime})},
            formatTime(e){if(isNaN(e))return"0:00";const t=Math.floor(e/60),s=Math.floor(e%60);return`${t}:${s<10?"0":""}${s}`},
            toggleRepeatMode(){const e=["none","all","one"],t=e.indexOf(this.state.repeatMode);this.state.repeatMode=e[(t+1)%e.length],this.updateRepeatButtonUI()},
            updateRepeatButtonUI(){this.dom.repeatBtn.classList.remove("text-green-500","repeat-mode-one"),"all"===this.state.repeatMode?this.dom.repeatBtn.classList.add("text-green-500"):"one"===this.state.repeatMode&&this.dom.repeatBtn.classList.add("text-green-500","repeat-mode-one")},
            toggleShuffle(){this.state.isShuffle=!this.state.isShuffle,this.updateShuffleButtonUI()},
            updateShuffleButtonUI(){this.dom.shuffleBtn.classList.toggle("text-green-500",this.state.isShuffle)},
            
            filterSongList: function(query) {
                const searchTerm = query.toLowerCase().trim();
                let filteredSongs;

                if (searchTerm.length > 0) {
                    filteredSongs = this.state.songs.filter(song => {
                        const title = song.title.toLowerCase();
                        const artist = (song.artist || '').toLowerCase();
                        return title.includes(searchTerm) || artist.includes(searchTerm);
                    });
                } else {
                    filteredSongs = this.state.songs;
                }

                const noResults = searchTerm.length > 0 && filteredSongs.length === 0;
                this.dom.libraryEmptyState.classList.toggle('hidden', !noResults);

                if (noResults) {
                    this.dom.libraryEmptyIcon.className = 'fas fa-search text-5xl mb-4';
                    this.dom.libraryEmptyTitle.textContent = 'Nenhum resultado encontrado';
                    this.dom.libraryEmptyText.textContent = 'Tente buscar por outro termo.';
                } else {
                    this.dom.libraryEmptyIcon.className = 'fas fa-music text-5xl mb-4';
                    this.dom.libraryEmptyTitle.textContent = 'Sua biblioteca está vazia';
                    this.dom.libraryEmptyText.innerHTML = 'Use o botão <i class="fas fa-folder-plus"></i> para começar.';
                    this.dom.libraryEmptyState.classList.toggle('hidden', this.state.songs.length > 0);
                }

                const scroller = VirtualScroller.get('song-list');
                if (scroller) {
                    scroller.setData(filteredSongs);
                }
            },
            
            showToast(message, type = 'info', duration = 1500) {
                if (this.state.activeToastTimeout) {
                    clearTimeout(this.state.activeToastTimeout);
                }
                this.dom.toastContainer.innerHTML = '';

                const toast = document.createElement('div');
                const icons = { success: 'fa-check-circle', error: 'fa-times-circle', info: 'fa-info-circle', };
                const colors = { success: 'bg-green-500', error: 'bg-red-500', info: 'bg-zinc-700', };
                const iconClass = icons[type] || icons['info'];
                const colorClass = colors[type] || colors['info'];
                toast.className = `flex items-center gap-3 text-white text-sm font-semibold p-3 rounded-lg shadow-2xl ${colorClass} toast-in`;
                toast.innerHTML = `<i class="fas ${iconClass} text-lg"></i><span>${message}</span>`;
                this.dom.toastContainer.appendChild(toast);

                this.state.activeToastTimeout = setTimeout(() => {
                    toast.classList.remove('toast-in');
                    toast.classList.add('toast-out');
                    toast.addEventListener('animationend', () => {
                        toast.remove();
                        this.state.activeToastTimeout = null;
                    });
                }, duration);
            },
            
            showPlaylistModal(e){e?(this.dom.createPlaylistModal.classList.remove("opacity-0","pointer-events-none"),this.dom.createPlaylistModal.querySelector(".modal-content").classList.remove("scale-95"),this.dom.playlistNameInput.focus()):(this.dom.createPlaylistModal.classList.add("opacity-0"),this.dom.createPlaylistModal.querySelector(".modal-content").classList.add("scale-95"),setTimeout(()=>{this.dom.createPlaylistModal.classList.add("pointer-events-none"),this.state.playlistIdToEdit=null},300))},
            showAddToPlaylistModal(e){e?(this.renderPlaylistSelectionList(),this.dom.addToPlaylistModal.classList.remove("opacity-0","pointer-events-none"),this.dom.addToPlaylistModal.querySelector(".modal-content").classList.remove("translate-y-full","sm:scale-95")):(this.dom.addToPlaylistModal.classList.add("opacity-0"),this.dom.addToPlaylistModal.querySelector(".modal-content").classList.add("translate-y-full","sm:scale-95"),setTimeout(()=>this.dom.addToPlaylistModal.classList.add("pointer-events-none"),300))},
            showSongOptionsModal(e){if(e){const t=this.state.songs.find(e=>e.id===this.state.songIdForOptions);t&&(this.dom.optionsModalTitle.textContent=t.title,this.dom.optionsModalArtist.textContent=t.artist||"Artista Desconhecido",this.dom.optionsAddToPlaylistLi.style.display=this.state.isPlaylistContextForOptions?"none":"block",this.dom.optionsRemoveFromPlaylistLi.style.display=this.state.isPlaylistContextForOptions?"block":"none",this.dom.optionsDownloadBtn.textContent=t.isOffline?"Remover do offline":"Baixar",t.isOffline?this.dom.optionsDownloadBtn.classList.add("text-red-500"):this.dom.optionsDownloadBtn.classList.remove("text-red-500"),this.dom.songOptionsModal.classList.remove("opacity-0","pointer-events-none"),this.dom.songOptionsModal.querySelector(".modal-content").classList.remove("translate-y-full","sm:scale-95"))}else this.dom.songOptionsModal.classList.add("opacity-0"),this.dom.songOptionsModal.querySelector(".modal-content").classList.add("translate-y-full","sm:scale-95"),setTimeout(()=>{this.dom.songOptionsModal.classList.add("pointer-events-none")},300)},
            showConfirmationModal(e,t,s=!0){s?(this.state.confirmationCallback=t,this.dom.confirmationModalText.textContent=e,this.dom.confirmationModal.classList.remove("opacity-0","pointer-events-none"),this.dom.confirmationModal.querySelector(".modal-content").classList.remove("scale-95")):(this.dom.confirmationModal.classList.add("opacity-0"),this.dom.confirmationModal.querySelector(".modal-content").classList.add("scale-95"),setTimeout(()=>{this.dom.confirmationModal.classList.add("pointer-events-none"),this.state.confirmationCallback=null},300))},
            showNotificationModal(message, show = true) {
                if (show) {
                    this.dom.notificationModalText.textContent = message;
                    this.dom.notificationModal.classList.remove('opacity-0', 'pointer-events-none');
                    this.dom.notificationModal.querySelector('.modal-content').classList.remove('scale-95');
                } else {
                    this.dom.notificationModal.classList.add('opacity-0');
                    this.dom.notificationModal.querySelector('.modal-content').classList.add('scale-95');
                    setTimeout(() => {
                        this.dom.notificationModal.classList.add('pointer-events-none');
                    }, 300);
                }
            },
            handlePlaylistFormSubmit() { this.state.playlistIdToEdit ? this.renamePlaylist() : this.createPlaylist(); },
            openCreatePlaylistModal() {
                this.dom.playlistModalTitle.textContent = "Criar nova playlist";
                this.dom.confirmPlaylistBtn.textContent = "Criar";
                this.dom.playlistNameInput.value = "";
                this.state.playlistIdToEdit = null;
                this.showPlaylistModal(true);
            },
            openRenamePlaylistModal(playlistId) {
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                if (!playlist) return;
                this.dom.playlistModalTitle.textContent = "Renomear Playlist";
                this.dom.confirmPlaylistBtn.textContent = "Salvar";
                this.dom.playlistNameInput.value = playlist.name;
                this.state.playlistIdToEdit = playlistId;
                this.showPlaylistModal(true);
            },
            async createPlaylist(){
                const name = this.dom.playlistNameInput.value.trim();
                if(!name) return;
                await this.savePlaylistToDB({name: name, songIds: []});
                this.showToast('Playlist criada com sucesso!', 'success');
                this.showPlaylistModal(false);
                await this.loadPlaylistsFromDB();
            },
            async renamePlaylist() {
                const newName = this.dom.playlistNameInput.value.trim();
                const playlistId = this.state.playlistIdToEdit;
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                if (!newName || !playlist) return;
                playlist.name = newName;
                await this.savePlaylistToDB(playlist);
                this.showToast('Playlist renomeada!', 'success');
                this.showPlaylistModal(false);
                await this.loadPlaylistsFromDB();
                if (this.state.currentPlaylistId === playlistId) {
                    this.dom.playlistDetailsTitle.textContent = newName;
                }
            },
            async deletePlaylist(e){
                const playlist = this.state.playlists.find(p => p.id === e);
                if(!playlist) return;
                this.showConfirmationModal(`Tem certeza que deseja excluir a playlist "${playlist.name}"?`,async()=>{
                    await this.deletePlaylistFromDB(e);
                    this.showToast('Playlist excluída.', 'info');
                    await this.loadPlaylistsFromDB();
                })
            },
            showPlaylistDetails(playlistId) {
                this.state.currentPlaylistId = playlistId;
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                if (!playlist) return;

                this.dom.playlistDetailsTitle.textContent = playlist.name;
                const songsInPlaylist = this.state.songs.filter(s => playlist.songIds.includes(s.id));
                const songCount = songsInPlaylist.length;
                const totalDuration = songsInPlaylist.reduce((acc, song) => acc + (song.duration || 0), 0);
                const totalMinutes = Math.floor(totalDuration / 60);

                this.dom.playlistDetailsMeta.textContent = `${songCount} música${songCount !== 1 ? 's' : ''}, aprox. ${totalMinutes} min`;

                const firstSong = songsInPlaylist[0];
                const highResCover = firstSong ? (firstSong.artworkBlob || firstSong.coverBlob) : null;
                if (highResCover) {
                    this.dom.playlistDetailsCoverImg.src = URL.createObjectURL(highResCover);
                    this.dom.playlistDetailsCoverImg.classList.remove("hidden");
                    this.dom.playlistDetailsCoverIcon.classList.add("hidden");
                } else {
                    this.dom.playlistDetailsCoverImg.classList.add("hidden");
                    this.dom.playlistDetailsCoverIcon.classList.remove("hidden");
                }

                this.dom.playlistEmptyState.classList.toggle('hidden', songCount > 0);
                this.dom.playlistSongList.classList.toggle('hidden', songCount === 0);
                
                if (songCount > 0) {
                    this.renderSongList(songsInPlaylist, this.dom.playlistSongList, true);
                }

                this.switchView("playlist-details-view");
            },

            async downloadPlaylist() {
                const playlist = this.state.playlists.find(p => p.id === this.state.currentPlaylistId);
                if (!playlist) return;
                const songsToDownload = playlist.songIds
                    .map(id => this.state.songs.find(s => s.id === id))
                    .filter(song => song && !song.isOffline);

                if (songsToDownload.length === 0) {
                    this.showToast('Todas as músicas já estão offline.', 'info');
                    return;
                }

                const btn = this.dom.playlistDownloadAllBtn;
                const originalIcon = btn.innerHTML;
                btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;
                btn.disabled = true;

                this.showToast(`Baixando ${songsToDownload.length} música(s)...`, 'info');

                for (const song of songsToDownload) {
                    await this.toggleSongOfflineStatus(song.id, false); 
                }

                btn.innerHTML = originalIcon;
                btn.disabled = false;

                this.showToast('Download da playlist concluído!', 'success');
            },

            updatePlayingSongUI(playingSongId) {
                document.querySelectorAll('.song-item').forEach(item => {
                    item.classList.remove('playing');
                });
                if (playingSongId === null || playingSongId === undefined) return;
                
                const currentSongItems = document.querySelectorAll(`.song-item[data-song-id="${playingSongId}"]`);
                currentSongItems.forEach(item => {
                    item.classList.add('playing');
                });
            },
            
            db: null,
            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open("SpobrefyDB", 4); 
                    request.onerror = e => reject("Erro ao abrir o DB"),
                    request.onsuccess = e => {
                        this.db = e.target.result;
                        resolve(this.db);
                    };
                    request.onupgradeneeded = e => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains("songs")) {
                            const songsStore = db.createObjectStore("songs", { keyPath: "id", autoIncrement: true });
                            songsStore.createIndex("title", "title", { unique: false });
                            songsStore.createIndex("artist", "artist", { unique: false });
                        }
                        if (db.objectStoreNames.contains("songData")) {
                             db.deleteObjectStore("songData");
                        }
                        if (!db.objectStoreNames.contains("playlists")) {
                            db.createObjectStore("playlists", { keyPath: "id", autoIncrement: true });
                        }
                    };
                });
            },

            async addMusicFiles(e) {
                this.showToast(`Adicionando ${e.length} músicas...`, 'info');
                try {
                    for (const t of e) {
                        const s = await this.readAudioMetadata(t);
                        const o = { ...s, path: null, isOffline: !0 };
                        const i = await this.saveSongMetadataToDB(o, !0);
                        await this._addSongToCache({ id: i }, t);
                    }
                    await this.loadSongsFromDB();
                    this.showToast('Músicas adicionadas com sucesso!', 'success');
                } catch (s) {
                    console.error("Erro ao processar os arquivos:", s);
                    this.showToast('Erro ao adicionar músicas.', 'error');
                }
            },
            async readAudioMetadata(e) {
                return new Promise(async (resolve, reject) => {
                    const s = document.createElement("audio");
                    s.src = URL.createObjectURL(e);
                    s.addEventListener("loadedmetadata", () => {
                        URL.revokeObjectURL(s.src);
                        jsmediatags.read(e, {
                            onSuccess: async (o) => {
                                const { title: i, artist: a, album: n, picture: l } = o.tags;
                                let originalCoverBlob = null;
                                let thumbnailBlob = null;
                                let artworkBlob = null;
                                if (l) {
                                    originalCoverBlob = new Blob([new Uint8Array(l.data)], { type: l.format });
                                    try {
                                        [thumbnailBlob, artworkBlob] = await Promise.all([
                                            this.createThumbnail(originalCoverBlob, 100, 100),
                                            this.createThumbnail(originalCoverBlob, 512, 512)
                                        ]);
                                    } catch (error) {
                                        console.error("Erro ao criar capas:", error);
                                    }
                                }
                                resolve({
                                    title: i || e.name.replace(/\.[^/.]+$/, ""),
                                    artist: a,
                                    album: n,
                                    coverBlob: thumbnailBlob,
                                    artworkBlob: artworkBlob,
                                    duration: s.duration
                                });
                            },
                            onError: (o) => {
                                console.warn("Erro ao ler metadados:", o);
                                resolve({
                                    title: e.name.replace(/\.[^/.]+$/, ""),
                                    artist: "Artista Desconhecido", album: null, coverBlob: null, artworkBlob: null, duration: s.duration
                                });
                            }
                        });
                    });
                    s.addEventListener('error', (err) => {
                        URL.revokeObjectURL(s.src);
                        reject(new Error('Erro ao carregar o arquivo de áudio para metadados.'));
                    });
                });
            },
            async readRemoteAudioMetadata(e){try{const t=await fetch(e);if(!t.ok)throw new Error(`Erro HTTP ao carregar ${e}: ${t.status}`);const s=await t.blob();return await this.readAudioMetadata(s)}catch(o){console.error("Erro Crítico ao processar arquivo remoto:",o);const i=e.split("/").pop();return{title:i.replace(/\.[^/.]+$/,""),artist:"Artista Desconhecido",album:null,coverBlob:null,duration:0}}},
            async saveSongMetadataToDB(e,t=!1){return this.db||await this.initDB(),new Promise((s,o)=>{const i=this.db.transaction(["songs"],"readwrite"),a=i.objectStore("songs"),n=a.put(e);n.onsuccess=e=>s(t?e.target.result:void 0),n.onerror=o})},
            
            async deleteSongFromDB(songId) {
                const songToDelete = this.state.songs.find(s => s.id === songId);
                if (songToDelete && songToDelete.isOffline) {
                    await this._removeSongFromCache(songToDelete);
                }
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(["songs"], "readwrite");
                    const store = transaction.objectStore("songs");
                    store.delete(songId);
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });
            },

            async loadSongsFromDB(){return this.db||await this.initDB(),new Promise((e,t)=>{const s=this.db.transaction(["songs"],"readonly"),o=s.objectStore("songs"),i=o.getAll();i.onsuccess=t=>{this.state.songs=t.target.result;this.renderSongList();this.updatePlayingSongUI(this.state.songs[this.state.currentSongIndex]?.id);e(this.state.songs)},i.onerror=t})},
            async savePlaylistToDB(e){return new Promise((t,s)=>{const o=this.db.transaction(["playlists"],"readwrite"),i=o.objectStore("playlists"),a=i.put(e);a.onsuccess=t,a.onerror=s})},
            async loadPlaylistsFromDB(){return new Promise((e,t)=>{const s=this.db.transaction(["playlists"],"readonly"),o=s.objectStore("playlists"),i=o.getAll();i.onsuccess=t=>{this.state.playlists=t.target.result,this.renderPlaylistGrid(),e(this.state.playlists)},i.onerror=t})},
            async deletePlaylistFromDB(e){return new Promise((t,s)=>{const o=this.db.transaction(["playlists"],"readwrite"),i=o.objectStore("playlists"),a=i.delete(e);a.onsuccess=t,a.onerror=s})},
            cleanupObjectURLs(e){e.querySelectorAll("img").forEach(e=>{e.src.startsWith("blob:")&&(URL.revokeObjectURL(e.src),e.src="https://placehold.co/100x100/27272a/3f3f46?text=?")})},
            cleanupItemURLs: function(element) {
                element.querySelectorAll('img').forEach(img => {
                    if (img.src.startsWith('blob:')) {
                        URL.revokeObjectURL(img.src);
                    }
                });
            },
            renderSongList: function(songs = this.state.songs, container = this.dom.songList, isPlaylistContext = false) {
                const containerId = container.id;
                
                if (this.virtualScrollers[containerId]) {
                    VirtualScroller.destroy(containerId);
                    this.virtualScrollers[containerId] = null;
                }

                if (container === this.dom.songList) {
                    this.dom.libraryEmptyState.classList.toggle('hidden', this.state.songs.length > 0);
                }

                if (songs.length === 0) {
                    container.innerHTML = '';
                    return;
                }

                this.virtualScrollers[containerId] = VirtualScroller.create(containerId, {
                    itemHeight: 64 + 4,
                    buffer: 10,
                    data: songs,
                    renderItem: (song, index) => {
                        const template = this.dom.songItemTemplate.content.cloneNode(true);
                        const item = template.querySelector('.song-item');
                        const cover = template.querySelector('.song-cover');

                        item.dataset.songId = song.id;
                        
                        if (song.coverBlob) {
                            cover.src = URL.createObjectURL(song.coverBlob);
                        } else {
                            cover.src = 'https://placehold.co/100x100/27272a/3f3f46?text=?';
                        }
                        
                        template.querySelector('.song-title').textContent = song.title;
                        template.querySelector('.song-artist').textContent = song.artist || 'Artista Desconhecido';
                        template.querySelector('.offline-indicator').classList.toggle('hidden', !song.isOffline);

                        if (song.id === this.state.songs[this.state.currentSongIndex]?.id) {
                            item.classList.add('playing');
                        }
                        
                        const wrapper = document.createElement('div');
                        wrapper.appendChild(template);
                        return wrapper.firstElementChild;
                    }
                });
                
                this.updatePlayingSongUI(this.state.songs[this.state.currentSongIndex]?.id);
            },
            renderPlaylistGrid(){this.cleanupObjectURLs(this.dom.playlistGrid),this.dom.playlistGrid.innerHTML="";const e=document.createDocumentFragment();this.state.playlists.forEach(t=>{const s=this.dom.playlistItemTemplate.content.cloneNode(!0),o=s.querySelector(".playlist-item-grid-entry"),i=s.querySelector(".playlist-cover");o.dataset.id=t.id,s.querySelector(".playlist-name").textContent=t.name,s.querySelector(".playlist-song-count").textContent=`${t.songIds.length} música${t.songIds.length!==1?"s":""}`;let a="https://placehold.co/100x100/101010/1DB954?text=PLAY";if(t.songIds.length>0){const n=this.state.songs.find(e=>e.id===t.songIds[0]);n&&n.coverBlob&&(a=URL.createObjectURL(n.coverBlob))}i.setAttribute("data-src",a),this.imageObserver.observe(i),e.appendChild(s)}),this.dom.playlistGrid.appendChild(e)},
            renderPlaylistSelectionList() {
                this.dom.playlistSelectionList.innerHTML = '';
                const songId = this.state.songIdForOptions;
                if (this.state.playlists.length === 0) {
                    this.dom.playlistSelectionList.innerHTML = `<p class="text-zinc-400 text-center p-4">Nenhuma playlist criada.</p>`;
                    return;
                }
                const fragment = document.createDocumentFragment();
                this.state.playlists.forEach(p => {
                    const button = document.createElement('button');
                    button.className = 'w-full flex items-center justify-between p-4 hover:bg-zinc-700 rounded-lg text-left';
                    button.dataset.playlistId = p.id;
                    const name = document.createElement('span');
                    name.textContent = p.name;
                    button.appendChild(name);
                    const songIsInPlaylist = p.songIds.includes(songId);
                    if (songIsInPlaylist) {
                        const check = document.createElement('i');
                        check.className = 'fas fa-check text-green-500';
                        button.appendChild(check);
                        button.disabled = true;
                        button.classList.add('opacity-60', 'cursor-not-allowed');
                    }
                    fragment.appendChild(button);
                });
                this.dom.playlistSelectionList.appendChild(fragment);
            }
        };

        App.init();
    });
</script>

</body>
</html>

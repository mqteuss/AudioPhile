<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spobrefy</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1DB954"/>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            color: #e5e5e5;
        }

        #app-background {
            position: fixed;
            top: -10px; left: -10px;
            width: calc(100% + 20px);
            height: calc(100% + 20px);
            background-size: cover;
            background-position: center;
            filter: blur(20px) brightness(0.4);
            transition: background-image 0.7s ease-in-out;
            z-index: -1;
        }

        #progress-bar {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            cursor: pointer;
            outline: none;
            border-radius: 15px;
            height: 18px; 
            background: transparent;
        }

        #progress-bar::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(to right, #1DB954 var(--progress-percent, 0%), rgba(255, 255, 255, 0.2) var(--progress-percent, 0%));
            border-radius: 15px;
            transition: height 0.2s ease-in-out;
        }
        #progress-bar::-moz-range-track {
            height: 4px;
            background: linear-gradient(to right, #1DB954 var(--progress-percent, 0%), rgba(255, 255, 255, 0.2) var(--progress-percent, 0%));
            border-radius: 15px;
            transition: height 0.2s ease-in-out;
        }

        #progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #e5e5e5;
            border-radius: 50%;
            border: none;
            margin-top: -6px; 
            transition: transform 0.2s ease-in-out, background 0.2s ease-in-out;
            transform: scale(0); 
        }
         #progress-bar::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #e5e5e5;
            border-radius: 50%;
            border: none;
            transition: transform 0.2s ease-in-out, background 0.2s ease-in-out;
            transform: scale(0);
        }

        .progress-container:hover #progress-bar::-webkit-slider-runnable-track {
            height: 6px;
        }
        .progress-container:hover #progress-bar::-webkit-slider-thumb {
            transform: scale(1); 
            margin-top: -5px; 
        }
         .progress-container:hover #progress-bar::-moz-range-track {
            height: 6px;
        }
        .progress-container:hover #progress-bar::-moz-range-thumb {
            transform: scale(1);
        }

        #progress-bar:active::-webkit-slider-thumb,
        #progress-bar:focus::-webkit-slider-thumb {
             background: #1DB954;
        }
        #progress-bar:active::-moz-range-thumb,
        #progress-bar:focus::-moz-range-thumb {
             background: #1DB954;
        }

        .view {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow-y: auto;
        }
        .view:not(.active) {
            opacity: 0;
            transform: scale(0.98);
            pointer-events: none;
        }

        .repeat-mode-one::after {
            content: '1';
            position: absolute;
            top: -2px; right: -4px;
            font-size: 9px;
            font-weight: bold;
            background-color: #1DB954;
            color: #121212;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            line-height: 12px;
            text-align: center;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }

        .modal-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        @keyframes nav-icon-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(0.85); }
            100% { transform: scale(1); }
        }
        .nav-icon-bounce {
            animation: nav-icon-bounce 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-black antialiased overflow-hidden">

    <div id="app-background"></div>

    <input type="file" id="music-folder-input" webkitdirectory directory multiple class="hidden">

    <main id="app-content" class="h-screen w-screen relative">

        <div id="player-view" class="view active flex flex-col justify-start items-center p-6 pt-10 md:pt-12">
            <div class="w-full max-w-sm">
                <img id="album-cover" src="https://placehold.co/500x500/101010/1DB954?text=Spobrefy" alt="Capa do Álbum" class="w-full aspect-square rounded-lg shadow-2xl object-cover">
                <div class="text-center my-8">
                    <h2 id="track-title" class="text-2xl font-bold truncate">Bem-vindo!</h2>
                    <h3 id="track-artist" class="text-md text-zinc-400 truncate">Sincronize ou adicione suas músicas</h3>
                </div>
                <div>
                     <div class="progress-container mb-2">
                         <input type="range" id="progress-bar" class="w-full appearance-none cursor-pointer" value="0" step="1">
                         <div class="flex justify-between text-xs text-zinc-400 mt-1.5">
                             <span id="current-time">0:00</span>
                             <span id="duration">0:00</span>
                         </div>
                     </div>
                     <div class="flex justify-between items-center text-zinc-200 px-2 my-6">
                         <button id="shuffle-btn" class="control-btn p-2 w-12 h-12 flex items-center justify-center transition-colors relative" title="Aleatório"><i class="fas fa-shuffle text-xl"></i></button>
                         <button id="prev-btn" class="control-btn p-2 transition-colors" title="Anterior"><i class="fas fa-backward-step text-4xl"></i></button>
                         <button id="play-pause-btn" class="control-btn bg-white text-black rounded-full w-20 h-20 flex items-center justify-center hover:scale-105 transition-transform shadow-lg" title="Play/Pause"><i class="fas fa-play text-3xl ml-1"></i></button>
                         <button id="next-btn" class="control-btn p-2 transition-colors" title="Próxima"><i class="fas fa-forward-step text-4xl"></i></button>
                         <button id="repeat-btn" class="control-btn p-2 w-12 h-12 flex items-center justify-center transition-colors relative" title="Repetir"><i class="fas fa-repeat text-xl"></i></button>
                     </div>
                </div>
            </div>
        </div>

        <div id="search-view" class="view p-6 md:p-8 pb-32">
            <h1 class="text-3xl font-bold mb-6">Buscar</h1>
            <div class="flex items-center gap-3 mb-6">
                <div class="relative flex-grow">
                    <input type="text" id="search-input" placeholder="O que você quer ouvir?" class="w-full bg-zinc-800 border border-zinc-700 rounded-lg px-4 py-3 pl-10 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-green-500">
                    <i class="fas fa-search absolute left-4 top-1/2 -translate-y-1/2 text-zinc-500"></i>
                </div>
                <button id="add-music-btn" title="Adicionar Pasta de Músicas" class="flex-shrink-0 text-zinc-400 hover:text-white bg-zinc-800 hover:bg-zinc-700 transition-colors w-12 h-12 flex items-center justify-center rounded-lg">
                    <i class="fas fa-folder-plus text-xl"></i>
                </button>
            </div>
            <div id="library-empty-state" class="text-center text-zinc-500 mt-16">
                <i class="fas fa-music text-5xl mb-4"></i>
                <h3 class="text-xl font-semibold text-white mb-2">Sua biblioteca está vazia</h3>
                <p>Use o botão <i class="fas fa-folder-plus"></i> para começar.</p>
            </div>
            <ul id="song-list" class="space-y-1 mt-4"></ul>
        </div>

        <div id="playlists-view" class="view p-6 md:p-8 pb-32">
             <h1 class="text-3xl font-bold mb-6">Suas Playlists</h1>
               <div id="playlist-grid" class="grid grid-cols-1 gap-4"></div>
        </div>

        <div id="playlist-details-view" class="view p-6 md:p-8 pb-32">
            <div class="flex items-center justify-between mb-6">
                <div class="flex items-center min-w-0">
                    <button id="back-to-playlists-btn" class="p-2 mr-2 flex-shrink-0"><i class="fas fa-arrow-left text-xl"></i></button>
                    <h1 id="playlist-details-title" class="text-3xl font-bold truncate">Nome da Playlist</h1>
                </div>
                <button id="add-songs-to-playlist-btn" title="Adicionar Músicas" class="flex-shrink-0 text-zinc-400 hover:text-white bg-zinc-800 hover:bg-zinc-700 transition-colors w-12 h-12 flex items-center justify-center rounded-lg ml-4">
                    <i class="fas fa-plus text-xl"></i>
                </button>
            </div>
            <ul id="playlist-song-list" class="space-y-1"></ul>
        </div>
    </main>

    <nav class="fixed bottom-0 left-0 right-0 h-[64px] bg-zinc-900/50 backdrop-blur-lg flex justify-around items-center border-t border-zinc-800">
        <button data-view="search-view" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-zinc-400 transition-colors">
            <i class="fas fa-search text-xl"></i>
            <span class="text-xs">Buscar</span>
        </button>
        <button data-view="player-view" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-green-500 transition-colors">
            <i class="fas fa-circle-play text-xl"></i>
            <span class="text-xs">Player</span>
        </button>
        <button data-view="playlists-view" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-zinc-400 transition-colors">
            <i class="fas fa-bars-staggered text-xl"></i>
            <span class="text-xs">Playlists</span>
        </button>
        <button id="create-playlist-btn" class="nav-btn flex flex-col items-center justify-center w-full h-full gap-1 text-zinc-400 transition-colors">
            <i class="fas fa-plus text-xl"></i>
            <span class="text-xs">Criar</span>
        </button>
    </nav>

    <div id="create-playlist-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-6 shadow-2xl transform scale-95">
             <h2 class="text-xl font-bold text-center mb-4">Criar nova playlist</h2>
             <input id="playlist-name-input" type="text" placeholder="Dê um nome à sua playlist" class="w-full bg-zinc-700 border-zinc-600 rounded-lg px-4 py-3 text-white placeholder-zinc-400 focus:outline-none focus:ring-2 focus:ring-green-500 mb-6">
             <div class="flex justify-end gap-3">
                 <button id="cancel-playlist-btn" class="px-5 py-2 rounded-full font-semibold transition-colors hover:bg-zinc-700">Cancelar</button>
                 <button id="confirm-playlist-btn" class="bg-green-500 text-black px-5 py-2 rounded-full font-semibold transition-colors hover:bg-green-400">Criar</button>
             </div>
        </div>
    </div>

    <div id="add-to-playlist-modal" class="modal-overlay fixed inset-0 bg-black/70 flex justify-center items-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content w-full max-w-sm bg-zinc-800 rounded-xl p-6 shadow-2xl transform scale-95">
             <h2 class="text-xl font-bold text-center mb-4">Adicionar à playlist</h2>
             <div id="playlist-selection-list" class="max-h-60 overflow-y-auto"></div>
        </div>
    </div>

    <template id="song-item-template">
        <li class="song-item group flex items-center gap-3 p-3 rounded-lg hover:bg-zinc-800/80 transition-colors">
            <div class="clickable-area flex-grow min-w-0 flex items-center gap-3 cursor-pointer">
                <img class="song-cover w-12 h-12 rounded-md object-cover" src="" alt="Capa">
                <div class="flex-grow min-w-0">
                    <p class="song-title font-semibold truncate"></p>
                    <p class="song-artist text-sm text-zinc-400 truncate"></p>
                </div>
            </div>
            <i class="offline-indicator fas fa-check-circle text-green-500 hidden" title="Disponível offline"></i>
            <p class="song-duration text-sm text-zinc-400 ml-auto pr-2"></p>
            <button class="download-btn text-zinc-400 hover:text-white p-2" title="Baixar música"><i class="fas fa-download"></i></button>
            <button class="playlist-action-btn text-zinc-400 hover:text-white p-2" title="Adicionar à playlist"><i class="fas fa-plus"></i></button>
        </li>
    </template>

    <template id="playlist-item-template">
        <div class="playlist-item-grid-entry group flex items-center justify-between gap-4 p-3 rounded-lg bg-zinc-900/50 hover:bg-zinc-800/80 transition-colors">
            <div class="playlist-clickable-area flex-grow flex items-center gap-4 cursor-pointer">
                <img class="playlist-cover w-16 h-16 rounded-md object-cover" src="" alt="Capa da Playlist">
                <div>
                    <p class="playlist-name font-semibold"></p>
                    <p class="playlist-song-count text-sm text-zinc-400"></p>
                </div>
            </div>
            <button class="delete-playlist-btn text-zinc-500 hover:text-red-500 p-2 opacity-0 group-hover:opacity-100 transition-opacity"><i class="fas fa-trash"></i></button>
        </div>
    </template>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const App = {
            dom: {
                appContent: document.getElementById('app-content'),
                background: document.getElementById('app-background'),
                albumCover: document.getElementById('album-cover'),
                trackTitle: document.getElementById('track-title'),
                trackArtist: document.getElementById('track-artist'),
                progressBar: document.getElementById('progress-bar'),
                currentTimeEl: document.getElementById('current-time'),
                durationEl: document.getElementById('duration'),
                playPauseBtn: document.getElementById('play-pause-btn'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                shuffleBtn: document.getElementById('shuffle-btn'),
                repeatBtn: document.getElementById('repeat-btn'),
                navButtons: document.querySelectorAll('.nav-btn'),
                views: document.querySelectorAll('.view'),
                addMusicBtn: document.getElementById('add-music-btn'),
                musicFolderInput: document.getElementById('music-folder-input'),
                songList: document.getElementById('song-list'),
                libraryEmptyState: document.getElementById('library-empty-state'),
                songItemTemplate: document.getElementById('song-item-template'),
                searchInput: document.getElementById('search-input'),
                playlistGrid: document.getElementById('playlist-grid'),
                playlistItemTemplate: document.getElementById('playlist-item-template'),
                createPlaylistBtn: document.getElementById('create-playlist-btn'),
                createPlaylistModal: document.getElementById('create-playlist-modal'),
                cancelPlaylistBtn: document.getElementById('cancel-playlist-btn'),
                confirmPlaylistBtn: document.getElementById('confirm-playlist-btn'),
                playlistNameInput: document.getElementById('playlist-name-input'),
                addToPlaylistModal: document.getElementById('add-to-playlist-modal'),
                playlistSelectionList: document.getElementById('playlist-selection-list'),
                playlistDetailsView: document.getElementById('playlist-details-view'),
                backToPlaylistsBtn: document.getElementById('back-to-playlists-btn'),
                playlistDetailsTitle: document.getElementById('playlist-details-title'),
                playlistSongList: document.getElementById('playlist-song-list'),
                addSongsToPlaylistBtn: document.getElementById('add-songs-to-playlist-btn'),
            },

            state: {
                songs: [],
                playlists: [],
                currentSongIndex: -1,
                isPlaying: false,
                isShuffle: false,
                repeatMode: 'none',
                songIdToAddToPlaylist: null,
                currentPlaylistId: null,
                playQueue: [], 
                currentQueueIndex: -1,
                restoredState: null,
                touchStartX: 0,
                touchEndX: 0,
                viewOrder: ['search-view', 'player-view', 'playlists-view'],
                currentObjectUrl: null,
            },

            audio: new Audio(),

            async init() {
                this.registerServiceWorker();
                await this.initDB();
                this.bindEvents();

                this.setupMediaSession();

                await this.loadSongsFromDB();
                await this.loadPlaylistsFromDB();
                
                console.log("🔄 Sincronizando catálogo com a pasta /Musics...");
                await this.syncWithServerFolder();

                await this.loadPlaybackState();

                this.updateRepeatButtonUI();
                this.updateShuffleButtonUI();

                if (this.state.currentSongIndex === -1) {
                    this.switchView('player-view');
                }
            },

            registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => console.log('Service Worker registrado com sucesso:', registration))
                        .catch(error => console.log('Falha ao registrar Service Worker:', error));
                }
            },
            
            animateIcon(element) {
                const icon = element.querySelector('i');
                if (icon) {
                    icon.classList.add('nav-icon-bounce');
                    icon.addEventListener('animationend', () => icon.classList.remove('nav-icon-bounce'), { once: true });
                }
            },

            bindEvents() {
                this.dom.addMusicBtn.addEventListener('click', () => this.dom.musicFolderInput.click());
                this.dom.musicFolderInput.addEventListener('change', (e) => this.addMusicFiles(e.target.files));
                this.dom.playPauseBtn.addEventListener('click', (e) => { this.togglePlayPause(); this.animateIcon(e.currentTarget); });
                this.dom.nextBtn.addEventListener('click', (e) => { this.changeTrack('next'); this.animateIcon(e.currentTarget); });
                this.dom.prevBtn.addEventListener('click', (e) => { this.changeTrack('prev'); this.animateIcon(e.currentTarget); });
                this.dom.repeatBtn.addEventListener('click', (e) => { this.toggleRepeatMode(); this.animateIcon(e.currentTarget); });
                this.dom.shuffleBtn.addEventListener('click', (e) => { this.toggleShuffle(); this.animateIcon(e.currentTarget); });
                this.dom.progressBar.addEventListener('input', (e) => this.seek(e.target.value));
                
                this.audio.addEventListener('timeupdate', () => this.updateProgress());
                this.audio.addEventListener('ended', () => this.handleSongEnd());
                this.audio.addEventListener('loadedmetadata', () => this.handleMetadataLoaded());
                this.audio.addEventListener('pause', () => this.savePlaybackState());
                this.audio.addEventListener('volumechange', () => this.savePlaybackState());
                window.addEventListener('beforeunload', () => this.savePlaybackState());

                this.dom.navButtons.forEach(btn => {
                    if(btn.dataset.view) {
                        btn.addEventListener('click', (e) => {
                            this.switchView(e.currentTarget.dataset.view);
                            this.animateIcon(e.currentTarget);
                        });
                    }
                });

                this.dom.searchInput.addEventListener('input', (e) => this.filterSongList(e.target.value));
                this.dom.createPlaylistBtn.addEventListener('click', () => this.showPlaylistModal(true));
                this.dom.cancelPlaylistBtn.addEventListener('click', () => this.showPlaylistModal(false));
                this.dom.confirmPlaylistBtn.addEventListener('click', () => this.createPlaylist());
                this.dom.createPlaylistModal.addEventListener('click', (e) => { if(e.target === this.dom.createPlaylistModal) this.showPlaylistModal(false); });
                this.dom.addToPlaylistModal.addEventListener('click', (e) => { if(e.target === this.dom.addToPlaylistModal) this.showAddToPlaylistModal(false); });

                this.dom.playlistSelectionList.addEventListener('click', (e) => {
                    const listItem = e.target.closest('[data-playlist-id]');
                    if(listItem) {
                        const playlistId = parseInt(listItem.dataset.playlistId);
                        this.addSongToPlaylist(this.state.songIdToAddToPlaylist, playlistId);
                    }
                });

                 this.dom.playlistGrid.addEventListener('click', e => {
                    const deleteBtn = e.target.closest('.delete-playlist-btn');
                    const clickableArea = e.target.closest('.playlist-clickable-area');

                    if (deleteBtn) {
                        const playlistEntry = e.target.closest('.playlist-item-grid-entry');
                        const playlistId = parseInt(playlistEntry.dataset.id);
                        this.deletePlaylist(playlistId);
                    } else if (clickableArea) {
                        const playlistEntry = e.target.closest('.playlist-item-grid-entry');
                        const playlistId = parseInt(playlistEntry.dataset.id);
                        this.showPlaylistDetails(playlistId);
                    }
                });

                this.dom.backToPlaylistsBtn.addEventListener('click', () => this.switchView('playlists-view'));
                this.dom.addSongsToPlaylistBtn.addEventListener('click', () => this.switchView('search-view'));
                
                this.dom.songList.addEventListener('click', (e) => this.handleSongListClick(e, this.state.songs));
                this.dom.playlistSongList.addEventListener('click', (e) => {
                    const playlist = this.state.playlists.find(p => p.id === this.state.currentPlaylistId);
                    if(playlist) {
                        const songsInPlaylist = this.state.songs.filter(song => playlist.songIds.includes(song.id));
                        this.handleSongListClick(e, songsInPlaylist, true);
                    }
                });
                
                this.dom.appContent.addEventListener('touchstart', (e) => this.handleTouchStart(e), false);
                this.dom.appContent.addEventListener('touchmove', (e) => this.handleTouchMove(e), false);
                this.dom.appContent.addEventListener('touchend', () => this.handleTouchEnd(), false);
            },
            
            setupMediaSession() {
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.setActionHandler('play', () => {
                        this.play();
                    });
                    navigator.mediaSession.setActionHandler('pause', () => {
                        this.pause();
                    });
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        this.changeTrack('next');
                    });
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        this.changeTrack('prev');
                    });
                }
            },

            handleTouchStart(event) {
                const target = event.target.closest('button, input[type="range"], .progress-container');
                if (target) {
                    this.state.touchStartX = 0;
                    return;
                }
                this.state.touchStartX = event.changedTouches[0].screenX;
            },

            handleTouchMove(event) {
                this.state.touchEndX = event.changedTouches[0].screenX;
            },

            handleTouchEnd() {
                if (this.state.touchStartX === 0 || this.state.touchEndX === 0) return;

                const threshold = 60; 
                const swipeDistance = this.state.touchEndX - this.state.touchStartX;
                const isSwipe = Math.abs(swipeDistance) > threshold;

                if (isSwipe) {
                    const activeView = document.querySelector('.view.active');
                    if (!activeView) return;

                    const currentIndex = this.state.viewOrder.indexOf(activeView.id);
                    if (currentIndex === -1) return;

                    let nextIndex;
                    if (swipeDistance < 0) {
                        nextIndex = Math.min(currentIndex + 1, this.state.viewOrder.length - 1);
                    } else {
                        nextIndex = Math.max(currentIndex - 1, 0);
                    }

                    if (nextIndex !== currentIndex) {
                        const nextViewId = this.state.viewOrder[nextIndex];
                        this.switchView(nextViewId);
                    }
                }
                this.state.touchStartX = 0;
                this.state.touchEndX = 0;
            },

            async handleSongListClick(event, songSourceList, isPlaylistContext = false) {
                const songItem = event.target.closest('.song-item');
                if (!songItem) return;

                const songId = parseInt(songItem.dataset.songId);
                const playlistActionBtn = event.target.closest('.playlist-action-btn');
                const downloadBtn = event.target.closest('.download-btn');
                
                if (downloadBtn) {
                    const song = this.state.songs.find(s => s.id === songId);
                    if (song) {
                        if (song.isOffline) {
                            await this.deleteOfflineSong(songId);
                        } else {
                            await this.downloadSong(songId);
                        }
                    }
                } else if (playlistActionBtn) {
                    if (isPlaylistContext) {
                        this.removeSongFromPlaylist(songId, this.state.currentPlaylistId);
                    } else {
                        this.state.songIdToAddToPlaylist = songId;
                        this.showAddToPlaylistModal(true);
                    }
                } else if (event.target.closest('.clickable-area')) {
                     this.state.playQueue = [...songSourceList]; 
                     const queueIndex = this.state.playQueue.findIndex(s => s.id === songId);
                     const globalIndex = this.state.songs.findIndex(s => s.id === songId);
                     
                     this.loadSong(globalIndex, true, queueIndex);
                     this.switchView('player-view');
                }
            },

            async downloadSong(songId) {
                const song = this.state.songs.find(s => s.id === songId);
                if (!song || song.isOffline) return;

                console.log(`📥 Baixando "${song.title}"...`);
                this.updateSongItemUI(songId, { isDownloading: true });

                try {
                    const response = await fetch(song.path);
                    if (!response.ok) throw new Error(`Falha ao baixar: ${response.statusText}`);
                    const blob = await response.blob();
                    
                    await this.saveSongDataToDB(song.id, blob);

                    song.isOffline = true;
                    await this.saveSongMetadataToDB(song);
                    
                    console.log(`✅ "${song.title}" baixada com sucesso!`);
                } catch (error) {
                    console.error("Erro no download:", error);
                } finally {
                    this.updateSongItemUI(songId, { isDownloading: false });
                }
            },
            
            async deleteOfflineSong(songId) {
                const song = this.state.songs.find(s => s.id === songId);
                if (!song || !song.isOffline) return;

                if (confirm(`Deseja remover a versão offline de "${song.title}"?`)) {
                    console.log(`🗑️ Removendo offline: "${song.title}"`);
                    await this.deleteSongDataFromDB(songId);
                    song.isOffline = false;
                    await this.saveSongMetadataToDB(song);
                    this.updateSongItemUI(songId);
                }
            },
            
            updateSongItemUI(songId, { isDownloading = false } = {}) {
                document.querySelectorAll(`.song-item[data-song-id="${songId}"]`).forEach(item => {
                    const song = this.state.songs.find(s => s.id === songId);
                    if (!song) return;

                    const downloadBtnIcon = item.querySelector('.download-btn i');
                    const offlineIndicator = item.querySelector('.offline-indicator');

                    downloadBtnIcon.className = 'fas';
                    if (isDownloading) {
                        downloadBtnIcon.classList.add('fa-spinner', 'fa-spin');
                        item.querySelector('.download-btn').disabled = true;
                    } else {
                        item.querySelector('.download-btn').disabled = false;
                        if (song.isOffline) {
                            downloadBtnIcon.classList.add('fa-trash-can');
                            item.querySelector('.download-btn').title = "Remover do offline";
                        } else {
                            downloadBtnIcon.classList.add('fa-download');
                            item.querySelector('.download-btn').title = "Baixar música";
                        }
                    }

                    offlineIndicator.classList.toggle('hidden', !song.isOffline);
                });
            },

            async syncWithServerFolder() {
                try {
                    const musicFiles = [
                        "Musics/Arctic Monkeys - Arabella (Official Audio)(MP3_160K).mp3",
                        "Musics/505(MP3_160K).mp3",
                        "Musics/Arctic Monkeys - Do I Wanna Know_ (Official Video)(MP3_160K).mp3",
                        "Musics/Art Deco.mp3",
                        "Musics/Bruno Mars - It Will Rain (Official Music Video)(MP3_160K).mp3",
                        "Musics/GIVĒON - Heartbreak Anniversary (Audio)(MP3_160K).mp3",
                        "Musics/GIVĒON - Make You Mine (Official Lyric Video)(MP3_160K).mp3",
                        "Musics/Get You (feat. Kali Uchis)(MP3_160K).mp3",
                        "Musics/I Wanna Be Yours(MP3_160K).mp3",
                        "Musics/Imogen Heap - Headlock (Official Video)(MP3_160K).mp3",
                        "Musics/LEOWOLF - Romantic Gangster(MP3_160K).mp3",
                        "Musics/Lady Gaga_ Bruno Mars - Die With A Smile (Official Music Video)(MP3_160K).mp3",
                        "Musics/Lied To(MP3_160K).mp3",
                        "Musics/Matt Maeson - Put It on Me(MP3_160K).mp3",
                        "Musics/No. 1 Party Anthem(MP3_160K).mp3",
                        "Musics/Sweater Weather(MP3_160K).mp3",
                        "Musics/Your Rarest of Flowers(MP3_160K).mp3",
                        "Musics/See You Again (Clean) - Tyler_ The Creator_Kali Uchis(MP3_160K).mp3",
                        "Musics/R U Mine_(MP3_160K).mp3",
                        "Musics/Coldplay - Yellow (Official Video)(MP3_160K).mp3",
                        "Musics/Goo Goo Dolls – Iris [Official Music Video] [4K Remaster](MP3_160K).mp3",
                        "Musics/James Blunt - Goodbye My Lover (Official Music Video) [4K](MP3_160K).mp3",
                        "Musics/James Blunt - Same Mistake (Official Music Video)(MP3_160K).mp3",
                        "Musics/James Blunt - You_re Beautiful (Official Music Video) [4K](MP3_160K).mp3",
                        "Musics/Olivia Rodrigo - favorite crime (Lyric Video)(MP3_160K).mp3",
                        "Musics/Olivia Rodrigo - happier (Lyric Video)(MP3_160K).mp3",
                        "Musics/Sabrina Carpenter - Manchild (Official Lyric Video)(MP3_160K).mp3",
                        "Musics/I Love You_ I_m Sorry(MP3_160K).mp3",
                       "Musics/if u think i_m pretty(MP3_160K).mp3",
                       "Musics/Die For You(MP3_160K).mp3",
                       "Musics/Coming Down(MP3_160K).mp3"
                    ];

                    let changesMade = false;
                    const serverFilePaths = musicFiles;
                    const localSongs = this.state.songs;

                    const localPaths = localSongs.map(song => song.path);
                    for (const path of serverFilePaths) {
                        if (!localPaths.includes(path)) {
                            changesMade = true;
                            console.log(`Lendo metadados de: ${path.split('/').pop()}`);
                            
                            const metadata = await this.readRemoteAudioMetadata(path);

                            const song = {
                                ...metadata,
                                path: path,
                                isOffline: false,
                            };
                            await this.saveSongMetadataToDB(song);
                        }
                    }

                    const songsToDelete = localSongs.filter(song => song.path && !serverFilePaths.includes(song.path));
                    if (songsToDelete.length > 0) {
                        console.log(`🗑️ Removendo ${songsToDelete.length} músicas obsoletas do catálogo...`);
                        changesMade = true;
                        for (const song of songsToDelete) {
                            console.log(`   - Deletando: ${song.title}`);
                            await this.deleteSongFromDB(song.id);
                        }
                    }

                    if (changesMade) {
                        console.log("🎶 Catálogo sincronizado. Recarregando dados...");
                        await this.loadSongsFromDB();
                        await this.loadPlaylistsFromDB();
                    } else {
                        console.log("✅ Catálogo já está atualizado.");
                    }
                } catch (error) {
                    console.error("Erro ao sincronizar músicas do servidor:", error);
                }
            },
            
            switchView(viewId) {
                this.dom.views.forEach(v => v.classList.toggle('active', v.id === viewId));
                this.dom.navButtons.forEach(b => {
                    if (b.dataset.view) {
                         b.classList.toggle('text-green-500', b.dataset.view === viewId);
                         b.classList.toggle('text-zinc-400', b.dataset.view !== viewId);
                    }
                });
            },

            async loadSong(globalIndex, shouldPlay = false, queueIndex = -1) {
                if (globalIndex < 0 || globalIndex >= this.state.songs.length) return;

                if (this.state.currentObjectUrl) {
                    URL.revokeObjectURL(this.state.currentObjectUrl);
                    this.state.currentObjectUrl = null;
                }

                this.state.currentSongIndex = globalIndex;
                const song = this.state.songs[globalIndex];
                this.state.currentQueueIndex = queueIndex;
                
                try {
                    if (song.isOffline) {
                        console.log(`▶️ Tocando offline: ${song.title}`);
                        const songData = await this.getSongDataFromDB(song.id);
                        if (songData) {
                            this.state.currentObjectUrl = URL.createObjectURL(songData);
                            this.audio.src = this.state.currentObjectUrl;
                        } else {
                            console.warn("Dado offline não encontrado, fazendo streaming.");
                            this.audio.src = song.path;
                        }
                    } else {
                        console.log(`▶️ Tocando online (streaming): ${song.title}`);
                        this.audio.src = song.path;
                    }
                } catch(e) {
                    console.error("Erro ao carregar áudio: ", e);
                    return;
                }

                this.updatePlayerUI(song);

                if ('mediaSession' in navigator) {
                    const coverUrl = song.coverUrl || 'https://placehold.co/500x500/101010/1DB954?text=Spobrefy';
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: song.title || 'Título Desconhecido',
                        artist: song.artist || 'Artista Desconhecido',
                        album: 'Spobrefy',
                        artwork: [
                            { src: coverUrl, sizes: '512x512', type: 'image/jpeg' },
                        ]
                    });
                }
                
                if (shouldPlay) this.play();
            },
            
            play() {
                if (this.state.songs.length === 0) return;
                this.state.isPlaying = true;
                this.audio.play()
                    .then(() => this.savePlaybackState())
                    .catch(e => console.error("Erro ao tocar:", e));
                this.dom.playPauseBtn.innerHTML = '<i class="fas fa-pause text-3xl"></i>';

                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'playing';
                }
            },

            pause() {
                this.state.isPlaying = false;
                this.audio.pause();
                this.dom.playPauseBtn.innerHTML = '<i class="fas fa-play text-3xl ml-1"></i>';

                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
            },

            togglePlayPause() {
                if (this.state.currentSongIndex === -1 && this.state.songs.length > 0) {
                     this.state.playQueue = [...this.state.songs];
                     this.loadSong(0, true, 0);
                } else {
                    this.state.isPlaying ? this.pause() : this.play();
                }
            },

            changeTrack(direction) {
                const source = this.state.playQueue.length > 0 ? this.state.playQueue : this.state.songs;
                if (source.length === 0) return;

                let newQueueIndex;
                const currentIndex = this.state.currentQueueIndex;

                if (this.state.isShuffle) {
                    do { newQueueIndex = Math.floor(Math.random() * source.length); } 
                    while (source.length > 1 && newQueueIndex === currentIndex);
                } else {
                    newQueueIndex = (direction === 'next') 
                        ? (currentIndex + 1) % source.length
                        : (currentIndex - 1 + source.length) % source.length;
                }

                const nextSong = source[newQueueIndex];
                const globalIndex = this.state.songs.findIndex(s => s.id === nextSong.id);
                this.loadSong(globalIndex, true, newQueueIndex);
            },

            handleSongEnd() {
                if (this.state.repeatMode === 'one') {
                    this.audio.currentTime = 0;
                    this.play();
                } else if (this.state.repeatMode === 'all' || this.state.repeatMode === 'none') {
                    const isLastInQueue = this.state.playQueue.length > 0 && this.state.currentQueueIndex === this.state.playQueue.length - 1;
                    if (this.state.repeatMode === 'all' || !isLastInQueue) {
                        this.changeTrack('next');
                    } else {
                        this.pause();
                        this.audio.currentTime = 0;
                    }
                }
            },
            
            handleMetadataLoaded() {
                this.updateProgress();
                if (this.state.restoredState && this.state.songs[this.state.currentSongIndex]?.id === this.state.restoredState.songId) {
                    this.audio.currentTime = this.state.restoredState.currentTime;
                    this.updateProgress(); 
                    this.state.restoredState = null;
                }
            },

            savePlaybackState() {
                if (this.state.currentSongIndex === -1) return;
                const song = this.state.songs[this.state.currentSongIndex];
                if (!song) return;

                const state = {
                    songId: song.id,
                    currentTime: this.audio.currentTime,
                    volume: this.audio.volume,
                };
                localStorage.setItem('spobrefyPlaybackState', JSON.stringify(state));
            },

            async loadPlaybackState() {
                const savedStateJSON = localStorage.getItem('spobrefyPlaybackState');
                if (savedStateJSON) {
                    try {
                        const savedState = JSON.parse(savedStateJSON);
                        
                        this.audio.volume = savedState.volume || 1;
                        const songIndex = this.state.songs.findIndex(s => s.id === savedState.songId);

                        if (songIndex > -1) {
                            console.log(`Restaurando estado: Música ID ${savedState.songId} no tempo ${this.formatTime(savedState.currentTime)}`);
                            this.state.restoredState = savedState;
                            this.loadSong(songIndex, false);
                            this.switchView('player-view');
                        }
                    } catch (error) {
                        console.error("Erro ao carregar o estado salvo:", error);
                        localStorage.removeItem('spobrefyPlaybackState');
                    }
                }
            },

            seek(value) {
                if(this.audio.duration) {
                    this.audio.currentTime = (value / 100) * this.audio.duration;
                    this.dom.progressBar.style.setProperty('--progress-percent', `${value}%`);
                }
            },

            updatePlayerUI(song) {
                this.dom.trackTitle.textContent = song.title || 'Título Desconhecido';
                this.dom.trackArtist.textContent = song.artist || 'Artista Desconhecido';
                const coverUrl = song.coverUrl || 'https://placehold.co/500x500/101010/1DB954?text=Spobrefy';
                this.dom.albumCover.src = coverUrl;
                this.dom.background.style.backgroundImage = `url(${coverUrl})`;
            },

            updateProgress() {
                const { duration, currentTime } = this.audio;
                if (duration) {
                    const progressPercent = (currentTime / duration) * 100;
                    this.dom.progressBar.value = progressPercent;
                    this.dom.progressBar.style.setProperty('--progress-percent', `${progressPercent}%`);
                    this.dom.durationEl.textContent = this.formatTime(duration);
                }
                this.dom.currentTimeEl.textContent = this.formatTime(currentTime);

                if ('mediaSession' in navigator && this.audio.duration) {
                    navigator.mediaSession.setPositionState({
                        duration: this.audio.duration,
                        playbackRate: this.audio.playbackRate,
                        position: this.audio.currentTime,
                    });
                }
            },

            formatTime(seconds) {
                if (isNaN(seconds)) return "0:00";
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
            },

            toggleRepeatMode() {
                const modes = ['none', 'all', 'one'];
                const currentIndex = modes.indexOf(this.state.repeatMode);
                this.state.repeatMode = modes[(currentIndex + 1) % modes.length];
                this.updateRepeatButtonUI();
            },

            updateRepeatButtonUI() {
                this.dom.repeatBtn.classList.remove('text-green-500', 'repeat-mode-one');
                if (this.state.repeatMode === 'all') this.dom.repeatBtn.classList.add('text-green-500');
                else if (this.state.repeatMode === 'one') this.dom.repeatBtn.classList.add('text-green-500', 'repeat-mode-one');
            },

            toggleShuffle() {
                this.state.isShuffle = !this.state.isShuffle;
                this.updateShuffleButtonUI();
            },

            updateShuffleButtonUI() {
                this.dom.shuffleBtn.classList.toggle('text-green-500', this.state.isShuffle);
            },

            filterSongList(term) {
                const lowerCaseTerm = term.toLowerCase().trim();
                const songItems = this.dom.songList.querySelectorAll('.song-item');
                songItems.forEach(item => {
                    const title = item.querySelector('.song-title').textContent.toLowerCase();
                    const artist = item.querySelector('.song-artist').textContent.toLowerCase();
                    const isVisible = title.includes(lowerCaseTerm) || artist.includes(lowerCaseTerm);
                    item.style.display = isVisible ? 'flex' : 'none';
                });
            },

            showPlaylistModal(show) {
                if(show) {
                    this.dom.createPlaylistModal.classList.remove('opacity-0', 'pointer-events-none');
                    this.dom.createPlaylistModal.querySelector('.modal-content').classList.remove('scale-95');
                    this.dom.playlistNameInput.focus();
                } else {
                    this.dom.createPlaylistModal.classList.add('opacity-0');
                    this.dom.createPlaylistModal.querySelector('.modal-content').classList.add('scale-95');
                    setTimeout(() => this.dom.createPlaylistModal.classList.add('pointer-events-none'), 300);
                }
            },
            showAddToPlaylistModal(show) {
                 if(show) {
                    this.renderPlaylistSelectionList();
                    this.dom.addToPlaylistModal.classList.remove('opacity-0', 'pointer-events-none');
                    this.dom.addToPlaylistModal.querySelector('.modal-content').classList.remove('scale-95');
                } else {
                    this.dom.addToPlaylistModal.classList.add('opacity-0');
                    this.dom.addToPlaylistModal.querySelector('.modal-content').classList.add('scale-95');
                    setTimeout(() => this.dom.addToPlaylistModal.classList.add('pointer-events-none'), 300);
                }
            },

            async createPlaylist() {
                const name = this.dom.playlistNameInput.value.trim();
                if(!name) return;
                const newPlaylist = { name, songIds: [] };
                await this.savePlaylistToDB(newPlaylist);
                this.dom.playlistNameInput.value = '';
                this.showPlaylistModal(false);
                await this.loadPlaylistsFromDB();
            },
            async deletePlaylist(playlistId) {
                if (confirm('Tem certeza que deseja excluir esta playlist?')) {
                    await this.deletePlaylistFromDB(playlistId);
                    await this.loadPlaylistsFromDB();
                }
            },
            async addSongToPlaylist(songId, playlistId) {
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                if (playlist && !playlist.songIds.includes(songId)) {
                    playlist.songIds.push(songId);
                    await this.savePlaylistToDB(playlist);
                    this.showAddToPlaylistModal(false);
                    await this.loadPlaylistsFromDB();
                }
            },
            async removeSongFromPlaylist(songId, playlistId) {
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                if (playlist) {
                    playlist.songIds = playlist.songIds.filter(id => id !== songId);
                    await this.savePlaylistToDB(playlist);
                    this.showPlaylistDetails(playlistId);
                    await this.loadPlaylistsFromDB();
                }
            },
            showPlaylistDetails(playlistId) {
                this.state.currentPlaylistId = playlistId;
                const playlist = this.state.playlists.find(p => p.id === playlistId);
                if(!playlist) return;

                this.dom.playlistDetailsTitle.textContent = playlist.name;
                const songsInPlaylist = this.state.songs.filter(song => playlist.songIds.includes(song.id));
                this.renderSongList(songsInPlaylist, this.dom.playlistSongList, true);
                this.switchView('playlist-details-view');
            },

            db: null,
            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('SpobrefyDB', 3);
                    request.onerror = (event) => reject("Erro ao abrir o DB");
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('songs')) { db.createObjectStore('songs', { keyPath: 'id', autoIncrement: true }); }
                        if (!db.objectStoreNames.contains('songData')) { db.createObjectStore('songData', { keyPath: 'id' }); }
                        if (!db.objectStoreNames.contains('playlists')) { db.createObjectStore('playlists', { keyPath: 'id', autoIncrement: true }); }
                    };
                });
            },

            async addMusicFiles(files) {
                try {
                    for (const file of files) {
                        const metadata = await this.readAudioMetadata(file);
                        const songMetadata = { 
                            title: metadata.title,
                            artist: metadata.artist,
                            album: metadata.album,
                            coverUrl: metadata.coverUrl,
                            path: null,
                            isOffline: true,
                        };
                        const id = await this.saveSongMetadataToDB(songMetadata, true);
                        await this.saveSongDataToDB(id, file); 
                    }
                    await this.loadSongsFromDB();
                } catch (error) {
                    console.error("Erro ao processar os arquivos:", error);
                }
            },
            
            async readAudioMetadata(file) {
                return new Promise(async (resolve) => {
                    jsmediatags.read(file, {
                        onSuccess: async (tag) => {
                            const { title, artist, album, picture } = tag.tags;
                            let coverUrl = null;
                            if (picture) {
                                const base64String = btoa(String.fromCharCode.apply(null, picture.data));
                                coverUrl = `data:${picture.format};base64,${base64String}`;
                            }
                            resolve({ title: title || file.name.replace(/\.[^/.]+$/, ""), artist, album, coverUrl });
                        },
                        onError: (error) => {
                            console.warn('Erro ao ler metadados:', error);
                            resolve({ title: file.name.replace(/\.[^/.]+$/, ""), artist: "Artista Desconhecido", album: null, coverUrl: null });
                        }
                    });
                });
            },
            
            async readRemoteAudioMetadata(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Erro HTTP ao carregar ${url}: ${response.status}`);
                    const blob = await response.blob();
                    return new Promise(async (resolve) => {
                        jsmediatags.read(blob, {
                            onSuccess: async (tag) => {
                                try {
                                    const { title, artist, album, picture } = tag.tags;
                                    let coverUrl = null;
                                    if (picture) {
                                        const base64String = btoa(String.fromCharCode(...new Uint8Array(picture.data)));
                                        coverUrl = `data:${picture.format};base64,${base64String}`;
                                    }
                                    const fileName = url.split('/').pop();
                                    resolve({
                                        title: title || fileName.replace(/\.[^/.]+$/, ""),
                                        artist: artist || "Artista Desconhecido",
                                        album: album,
                                        coverUrl,
                                    });
                                } catch (error) {
                                    console.error(`Erro ao processar metadados de "${url}":`, error);
                                    const fileName = url.split('/').pop();
                                    resolve({
                                        title: fileName.replace(/\.[^/.]+$/, ""), artist: "Artista Desconhecido", album: null, coverUrl: null
                                    });
                                }
                            },
                            onError: (error) => {
                                console.warn(`jsmediatags não conseguiu ler o arquivo: ${url}`, error);
                                const fileName = url.split('/').pop();
                                resolve({
                                    title: fileName.replace(/\.[^/.]+$/, ""), artist: "Artista Desconhecido", album: null, coverUrl: null
                                });
                            }
                        });
                    });
                } catch (error) {
                   console.error("Erro Crítico ao processar arquivo remoto:", error);
                    const fileName = url.split('/').pop();
                    return {
                        title: fileName.replace(/\.[^/.]+$/, ""), artist: "Artista Desconhecido", album: null, coverUrl: null
                    };
                }
            },
            
            async saveSongMetadataToDB(song, returnId = false) {
                if (!this.db) await this.initDB();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['songs'], 'readwrite');
                    const store = transaction.objectStore('songs');
                    const request = store.put(song);
                    request.onsuccess = (event) => resolve(returnId ? event.target.result : undefined);
                    request.onerror = reject;
                });
            },

            async saveSongDataToDB(songId, blob) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['songData'], 'readwrite');
                    const store = transaction.objectStore('songData');
                    store.put({ id: songId, data: blob });
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });
            },

            async getSongDataFromDB(songId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['songData'], 'readonly');
                    const store = transaction.objectStore('songData');
                    const request = store.get(songId);
                    request.onsuccess = (event) => resolve(event.target.result?.data);
                    request.onerror = reject;
                });
            },

            async deleteSongDataFromDB(songId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['songData'], 'readwrite');
                    const store = transaction.objectStore('songData');
                    store.delete(songId);
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });
            },

            async deleteSongFromDB(songId) {
                await this.deleteSongDataFromDB(songId);
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['songs'], 'readwrite');
                    const store = transaction.objectStore('songs');
                    store.delete(songId);
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });
            },

            async loadSongsFromDB() {
                if (!this.db) await this.initDB();
                 return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['songs'], 'readonly');
                    const store = transaction.objectStore('songs');
                    const request = store.getAll();
                    request.onsuccess = (event) => {
                        this.state.songs = event.target.result;
                        this.renderSongList();
                        resolve(this.state.songs);
                    };
                    request.onerror = reject;
                 });
            },

            async savePlaylistToDB(playlist) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['playlists'], 'readwrite');
                    const store = transaction.objectStore('playlists');
                    const request = store.put(playlist);
                    request.onsuccess = resolve;
                    request.onerror = reject;
                });
            },
             async loadPlaylistsFromDB() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['playlists'], 'readonly');
                    const store = transaction.objectStore('playlists');
                    const request = store.getAll();
                    request.onsuccess = (event) => {
                        this.state.playlists = event.target.result;
                        this.renderPlaylistGrid();
                        resolve(this.state.playlists);
                    };
                    request.onerror = reject;
                });
            },
            async deletePlaylistFromDB(playlistId) {
                 return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['playlists'], 'readwrite');
                    const store = transaction.objectStore('playlists');
                    const request = store.delete(playlistId);
                    request.onsuccess = resolve;
                    request.onerror = reject;
                });
            },

            renderSongList(songsToRender = this.state.songs, container = this.dom.songList, isPlaylistContext = false) {
                container.innerHTML = '';
                const hasSongs = songsToRender.length > 0;
                if (container === this.dom.songList) {
                    this.dom.libraryEmptyState.classList.toggle('hidden', this.state.songs.length > 0);
                }
                if(hasSongs) {
                    const fragment = document.createDocumentFragment();
                    songsToRender.forEach((song) => {
                        const item = this.dom.songItemTemplate.content.cloneNode(true);
                        const li = item.querySelector('.song-item');
                        const playlistActionBtnIcon = item.querySelector('.playlist-action-btn i');
                        const downloadBtn = item.querySelector('.download-btn');
                        const downloadBtnIcon = downloadBtn.querySelector('i');
                        const offlineIndicator = item.querySelector('.offline-indicator');

                        li.dataset.songId = song.id;
                        const placeholder = 'https://placehold.co/100x100/27272a/3f3f46?text=?';
                        item.querySelector('.song-cover').src = song.coverUrl || placeholder;
                        item.querySelector('.song-title').textContent = song.title;
                        item.querySelector('.song-artist').textContent = song.artist || 'Artista Desconhecido';
                        if (isPlaylistContext) {
                            playlistActionBtnIcon.classList.remove('fa-plus');
                            playlistActionBtnIcon.classList.add('fa-trash-can');
                            playlistActionBtnIcon.parentElement.title = "Remover da playlist";
                        }
                        if (song.isOffline) {
                            downloadBtnIcon.classList.remove('fa-download');
                            downloadBtnIcon.classList.add('fa-trash-can');
                            downloadBtn.title = "Remover do offline";
                            offlineIndicator.classList.remove('hidden');
                        } else {
                            downloadBtn.classList.toggle('hidden', !song.path);
                        }
                        fragment.appendChild(item);
                    });
                    container.appendChild(fragment);
                }
            },
            
            renderPlaylistGrid() {
                this.dom.playlistGrid.innerHTML = '';
                const fragment = document.createDocumentFragment();
                this.state.playlists.forEach(playlist => {
                    const item = this.dom.playlistItemTemplate.content.cloneNode(true);
                    const entry = item.querySelector('.playlist-item-grid-entry');
                    entry.dataset.id = playlist.id;
                    item.querySelector('.playlist-name').textContent = playlist.name;
                    item.querySelector('.playlist-song-count').textContent = `${playlist.songIds.length} músicas`;
                    if (playlist.songIds.length > 0) {
                        const firstSong = this.state.songs.find(s => s.id === playlist.songIds[0]);
                        if (firstSong && firstSong.coverUrl) {
                            item.querySelector('.playlist-cover').src = firstSong.coverUrl;
                        } else {
                            item.querySelector('.playlist-cover').src = 'https://placehold.co/100x100/101010/1DB954?text=PLAY';
                        }
                    } else {
                         item.querySelector('.playlist-cover').src = 'https://placehold.co/100x100/101010/1DB954?text=PLAY';
                    }
                    fragment.appendChild(item);
                });
                this.dom.playlistGrid.appendChild(fragment);
            },
            renderPlaylistSelectionList() {
                this.dom.playlistSelectionList.innerHTML = '';
                if(this.state.playlists.length === 0) {
                    this.dom.playlistSelectionList.innerHTML = `<p class="text-zinc-400 text-center">Nenhuma playlist criada.</p>`;
                    return;
                }
                const fragment = document.createDocumentFragment();
                this.state.playlists.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'p-3 rounded-lg hover:bg-zinc-700 cursor-pointer';
                    div.textContent = p.name;
                    div.dataset.playlistId = p.id;
                    fragment.appendChild(div);
                });
                this.dom.playlistSelectionList.appendChild(fragment);
            },
        };

        App.init();
    });
    </script>
    </body>
</html>